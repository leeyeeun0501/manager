// room-manage/edit
"use client"
import React, { useEffect, useRef, useState } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import styles from "../room-manage.module.css"
import { apiGet, parseJsonResponse } from "../../utils/apiHelper"
import Menu from "../../components/menu"
import { useSessionCheck } from "../../utils/useSessionCheck"

export default function RoomManageEditPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const building = searchParams.get("building") || ""
  const floor = searchParams.get("floor") || ""
  const [menuOpen, setMenuOpen] = useState(false)

  const [svgRaw, setSvgRaw] = useState("")
  const [svgViewBox, setSvgViewBox] = useState({ x: 0, y: 0, width: 400, height: 400 })
  const [edges, setEdges] = useState([])
  const [svgNodes, setSvgNodes] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState("")
  const [showNodeModal, setShowNodeModal] = useState(false)
  const [showCategoryModal, setShowCategoryModal] = useState(false)
  const [newNodeName, setNewNodeName] = useState("")
  const [newCategoryName, setNewCategoryName] = useState("")
  const [selectedCategory, setSelectedCategory] = useState("")
  const [nodeType, setNodeType] = useState("stairs") // "stairs" or "normal"
  const [autoGeneratedName, setAutoGeneratedName] = useState("")
  const [nodeCounter, setNodeCounter] = useState(1)
  const [pendingNodes, setPendingNodes] = useState([]) // 임시로 추가된 노드들
  const [isAddingMode, setIsAddingMode] = useState(false) // 노드 추가 모드
  const [pendingCategories, setPendingCategories] = useState([]) // 임시로 추가된 카테고리들
  const [isAddingCategoryMode, setIsAddingCategoryMode] = useState(false) // 카테고리 추가 모드

  const CANVAS_WIDTH = 1000
  const CANVAS_HEIGHT = 700
  const mapContainerRef = useRef(null)

  // 카테고리 한글-영어 매핑
  const categoryNameMap = {
    cafe: "카페",
    restaurant: "식당",
    convenience: "편의점",
    vending: "자판기",
    water_purifier: "정수기",
    printer: "프린터",
    lounge: "라운지",
    bank: "은행(atm)",
    fire_extinguisher: "소화기",
    gym: "헬스장",
    bookstore: "서점",
    post: "우체국",
  }

  // 미리 정의된 카테고리 목록 (한글 표시용)
  const categoryOptions = Object.values(categoryNameMap)

  // 기존 노드명과 중복되지 않는 다음 번호 찾기
  const findNextAvailableNodeNumber = () => {
    const existingNodeIds = svgNodes.map(node => node.id.split("@")[2]) // building@floor@nodeId에서 nodeId만 추출
    const pendingNodeIds = pendingNodes.map(node => node.id.split("@")[2]) // 임시 노드들의 ID도 확인
    
    let counter = 1
    while (true) {
      const candidateId = `b${counter}`
      if (!existingNodeIds.includes(candidateId) && !pendingNodeIds.includes(candidateId)) {
        return counter
      }
      counter++
    }
  }

  // 자동 생성 노드명 업데이트
  useEffect(() => {
    if (nodeType === "normal") {
      const nextAvailableNumber = findNextAvailableNodeNumber()
      setNodeCounter(nextAvailableNumber)
      setAutoGeneratedName(`b${nextAvailableNumber}`)
    }
  }, [nodeType, svgNodes, pendingNodes])

  // 도면 클릭 핸들러
  const handleMapClick = (event) => {
    if (!isAddingMode && !isAddingCategoryMode) return

    // SVG 컨테이너의 실제 크기와 위치 가져오기
    const containerRect = mapContainerRef.current.getBoundingClientRect()
    const scale = Math.min(CANVAS_WIDTH / svgViewBox.width, CANVAS_HEIGHT / svgViewBox.height)
    const offsetX = (CANVAS_WIDTH - svgViewBox.width * scale) / 2
    const offsetY = (CANVAS_HEIGHT - svgViewBox.height * scale) / 2

    // 클릭한 위치를 SVG 좌표계로 변환 (더 간단한 방법)
    const relativeX = event.clientX - containerRect.left
    const relativeY = event.clientY - containerRect.top
    
    // SVG 컨테이너 내에서의 비율 계산
    const clickX = (relativeX / containerRect.width) * svgViewBox.width
    const clickY = (relativeY / containerRect.height) * svgViewBox.height


    if (isAddingMode) {
      // 노드 추가 모드
      let newNodeId
      if (nodeType === "stairs") {
        newNodeId = newNodeName.trim()
      } else {
        // 일반 노드인 경우 중복되지 않는 다음 번호 사용
        const nextAvailableNumber = findNextAvailableNodeNumber()
        newNodeId = `b${nextAvailableNumber}`
        setNodeCounter(nextAvailableNumber)
      }
      const newNode = {
        id: `${building}@${floor}@${newNodeId}`,
        x: clickX,
        y: clickY,
        width: 8, // 기존 노드들과 비슷한 크기
        height: 8, // 기존 노드들과 비슷한 크기
        element: "circle",
        layer: "Navigation_Nodes",
        nodeType: nodeType,
        isPending: true
      }


      setPendingNodes(prev => [...prev, newNode])

      // 모달 닫기
      setShowNodeModal(false)
      setIsAddingMode(false)
    } else if (isAddingCategoryMode) {
      // 카테고리 추가 모드
      const englishCategoryName = Object.keys(categoryNameMap).find(
        key => categoryNameMap[key] === selectedCategory
      )
      
      const newCategory = {
        id: `${building}@${floor}@${englishCategoryName}`,
        x: clickX,
        y: clickY,
        width: 8,
        height: 8,
        element: "circle",
        layer: "Categories",
        categoryType: englishCategoryName,
        isPending: true
      }


      setPendingCategories(prev => [...prev, newCategory])
      setShowCategoryModal(false)
      setIsAddingCategoryMode(false)
    }
  }

  function parseNodeInfo(fullId) {
    const parts = (fullId || "").split("@")
    if (parts.length < 3) return { building: "", floor: "", node: "" }
    return { building: parts[0], floor: parts[1], node: parts[2] }
  }

  const handleAddNode = () => {
    // 계단인 경우 노드 이름이 필요
    if (nodeType === "stairs" && !newNodeName.trim()) {
      alert("노드명을 입력해주세요.")
      return
    }
    
    // 노드 추가 모드로 전환
    setIsAddingMode(true)
    setShowNodeModal(false)
    alert("도면에서 노드를 추가할 위치를 클릭해주세요.")
  }


  // SVG에 노드 추가하는 함수
  const addNodesToSvg = (svgXml, nodes, categories = []) => {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    
    let navigationLayer = doc.querySelector('g[id="Navigation_Nodes"]') ||
                         doc.querySelector('g[id="navigation_nodes"]') ||
                         doc.querySelector('g[id="Navigation_nodes"]') ||
                         doc.querySelector('g[id="navigation-nodes"]')

    // Navigation_Nodes 레이어가 없으면 생성
    if (!navigationLayer) {
      navigationLayer = doc.createElementNS("http://www.w3.org/2000/svg", "g")
      navigationLayer.setAttribute("id", "Navigation_Nodes")
      doc.querySelector("svg").appendChild(navigationLayer)
    }

    // Categories 레이어 찾기
    let categoriesLayer = doc.querySelector('g[id="Categories"]') ||
                         doc.querySelector('g[id="categories"]') ||
                         doc.querySelector('g[id="Category"]') ||
                         doc.querySelector('g[id="category"]')

    // Categories 레이어가 없으면 생성
    if (!categoriesLayer) {
      categoriesLayer = doc.createElementNS("http://www.w3.org/2000/svg", "g")
      categoriesLayer.setAttribute("id", "Categories")
      doc.querySelector("svg").appendChild(categoriesLayer)
    }

    // 각 노드를 SVG 요소로 추가 (기존 노드와 동일한 스타일)
    nodes.forEach((node) => {
      const nodeId = node.id.split("@")[2] // building@floor@nodeId에서 nodeId만 추출
      
      const circle = doc.createElementNS("http://www.w3.org/2000/svg", "circle")
      circle.setAttribute("id", nodeId)
      circle.setAttribute("cx", node.x)
      circle.setAttribute("cy", node.y)
      circle.setAttribute("r", "2.1957438") // 기존 노드와 동일한 반지름
      circle.setAttribute("style", "fill:#00ffff;fill-opacity:0;stroke:#ffffff;stroke-width:0") // 기존 노드와 동일한 스타일
      
      navigationLayer.appendChild(circle)
    })

    // 각 카테고리를 SVG 요소로 추가 (카테고리는 투명하게 설정)
    categories.forEach((category) => {
      const categoryId = category.id.split("@")[2] // building@floor@categoryId에서 categoryId만 추출
      
      const circle = doc.createElementNS("http://www.w3.org/2000/svg", "circle")
      circle.setAttribute("id", categoryId)
      circle.setAttribute("cx", category.x)
      circle.setAttribute("cy", category.y)
      circle.setAttribute("r", "2.1957438") // 기존 노드와 동일한 반지름
      circle.setAttribute("style", "fill:#ff6b6b;fill-opacity:0;stroke:#ff6b6b;stroke-opacity:0;stroke-width:0") // 카테고리는 완전 투명하게 설정
      
      categoriesLayer.appendChild(circle)
    })

    return doc.documentElement.outerHTML
  }

  const handleAddCategory = () => {
    if (!selectedCategory) {
      alert("카테고리를 선택해주세요.")
      return
    }

    // 카테고리 추가 모드로 전환
    setIsAddingCategoryMode(true)
    setShowCategoryModal(false)
    alert("도면에서 카테고리를 추가할 위치를 클릭해주세요.")
  }

  // SVG 저장 함수
  const handleSaveSvg = async () => {
    if (!building || !floor) {
      alert("건물과 층 정보가 없습니다.")
      return
    }

    try {
      setLoading(true)
      
      // 현재 SVG에 노드와 카테고리 추가
      const updatedSvg = addNodesToSvg(svgRaw, pendingNodes, pendingCategories)
      
      // SVG를 Blob으로 변환
      const svgBlob = new Blob([updatedSvg], { type: 'image/svg+xml' })
      
      // FormData 생성
      const formData = new FormData()
      formData.append('file', svgBlob, `${building}_${floor}.svg`)
      
      // floor-route PUT API 사용
      const token = localStorage.getItem('token')
      const response = await fetch(`/api/floor-route?building=${encodeURIComponent(building)}&floor=${encodeURIComponent(floor)}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`
        },
        body: formData
      })

      const data = await response.json()
      
      if (response.ok) {
        alert("SVG가 성공적으로 저장되었습니다.")
        // 저장 성공 후 임시 데이터 초기화
        setPendingNodes([])
        setPendingCategories([])
      } else {
        alert("SVG 저장에 실패했습니다: " + (data.error || "알 수 없는 오류"))
      }
    } catch (error) {
      console.error("SVG 저장 오류:", error)
      alert("SVG 저장 중 오류가 발생했습니다: " + error.message)
    } finally {
      setLoading(false)
    }
  }

  function processSvg(svgXml) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    const svgEl = doc.querySelector("svg")
    if (!svgEl) return svgXml

    const existingViewBox = svgEl.getAttribute("viewBox")
    if (existingViewBox) {
      const parts = existingViewBox.split(/[\s,]+/).map(Number)
      if (parts.length === 4) {
        setSvgViewBox({ x: parts[0], y: parts[1], width: parts[2], height: parts[3] })
        return svgXml
      }
    }

    const width = parseFloat(svgEl.getAttribute("width")) || 400
    const height = parseFloat(svgEl.getAttribute("height")) || 400
    const viewBoxStr = `0 0 ${width} ${height}`
    svgEl.setAttribute("viewBox", viewBoxStr)
    setSvgViewBox({ x: 0, y: 0, width, height })
    svgEl.removeAttribute("width")
    svgEl.removeAttribute("height")

    return doc.documentElement.outerHTML
  }

  function parseSvgNodes(svgXml, buildingName, floorName) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    const nodes = []

    const navigationLayer =
      doc.querySelector('g[id="Navigation_Nodes"]') ||
      doc.querySelector('g[id="navigation_nodes"]') ||
      doc.querySelector('g[id="Navigation_nodes"]') ||
      doc.querySelector('g[id="navigation-nodes"]')

    if (!navigationLayer) {
      return []
    }

    const allElements = navigationLayer.querySelectorAll("*[id]")
    allElements.forEach((element) => {
      const nodeSuffix = element.getAttribute("id")
      if (!nodeSuffix) return
      const fullNodeId = `${buildingName}@${floorName}@${nodeSuffix}`

      let x = 0, y = 0, width = 0, height = 0
      switch (element.tagName.toLowerCase()) {
        case "rect":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 0)
          height = parseFloat(element.getAttribute("height") || 0)
          break
        case "circle":
          x = parseFloat(element.getAttribute("cx") || 0)
          y = parseFloat(element.getAttribute("cy") || 0)
          width = height = parseFloat(element.getAttribute("r") || 0) * 2
          break
        case "ellipse":
          x = parseFloat(element.getAttribute("cx") || 0)
          y = parseFloat(element.getAttribute("cy") || 0)
          width = parseFloat(element.getAttribute("rx") || 0) * 2
          height = parseFloat(element.getAttribute("ry") || 0) * 2
          break
        case "line":
          x = parseFloat(element.getAttribute("x1") || 0)
          y = parseFloat(element.getAttribute("y1") || 0)
          const x2 = parseFloat(element.getAttribute("x2") || 0)
          const y2 = parseFloat(element.getAttribute("y2") || 0)
          width = Math.abs(x2 - x)
          height = Math.abs(y2 - y)
          break
        case "polygon":
        case "polyline":
          const points = element.getAttribute("points") || ""
          const pointsArray = points.split(/[\s,]+/).filter((p) => p).map(Number)
          if (pointsArray.length >= 2) {
            const xCoords = pointsArray.filter((_, i) => i % 2 === 0)
            const yCoords = pointsArray.filter((_, i) => i % 2 === 1)
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "path":
          const d = element.getAttribute("d") || ""
          const matches = d.match(/[ML]\s*([0-9.-]+)\s*,?\s*([0-9.-]+)/g)
          if (matches && matches.length > 0) {
            const coords = matches.map((m) => {
              const nums = m.replace(/[ML]\s*/, "").split(/[\s,]+/).map(Number)
              return { x: nums[0] || 0, y: nums[1] || 0 }
            })
            const xCoords = coords.map((c) => c.x)
            const yCoords = coords.map((c) => c.y)
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "text":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = element.textContent ? element.textContent.length * 8 : 50
          height = 20
          break
        case "g":
          const transform = element.getAttribute("transform") || ""
          const translateMatch = transform.match(/translate\(([^)]+)\)/)
          if (translateMatch) {
            const translateValues = translateMatch[1].split(/[\s,]+/).map(Number)
            x = translateValues[0] || 0
            y = translateValues[1] || 0
          }
          width = height = 20
          break
        default:
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 20)
          height = parseFloat(element.getAttribute("height") || 20)
      }

      nodes.push({ id: fullNodeId, x, y, width, height, element: element.tagName.toLowerCase(), layer: "Navigation_Nodes" })
    })

    return nodes
  }

  useEffect(() => {
    if (!building || !floor) return

    setLoading(true)
    setError("")

    apiGet(`/api/map-route?building=${encodeURIComponent(building)}&floor=${encodeURIComponent(floor)}`)
      .then(async (res) => parseJsonResponse(res))
      .then((data) => {
        const fileList = Array.isArray(data) ? data : [data]
        const rawSvgUrl = fileList[0]?.File
        const nodesInfo = fileList[0]?.nodes || {}
        let edgesInfo = fileList[0]?.edges

        if (!edgesInfo) {
          edgesInfo = []
          Object.entries(nodesInfo).forEach(([from, arr]) => {
            arr.forEach((edgeObj) => {
              const to = typeof edgeObj === "string" ? edgeObj : (edgeObj.node || edgeObj.to)
              if (to) edgesInfo.push({ from, to })
            })
          })
        }

        if (rawSvgUrl) {
          const svgUrl = rawSvgUrl + (rawSvgUrl.includes("?") ? "&" : "?") + "ts=" + Date.now()
          setSvgRaw("")
          setSvgNodes([])
          setEdges([])

          fetch(svgUrl)
            .then((res) => res.text())
            .then((svgXml) => {
              const processedSvg = processSvg(svgXml)
              setSvgRaw(processedSvg)
              setEdges(edgesInfo)
              const parsedNodes = parseSvgNodes(svgXml, building, floor)
              setSvgNodes(parsedNodes)
            })
            .catch(() => {
              setSvgRaw("")
              setSvgNodes([])
              setEdges([])
              setError("도면을 불러오지 못했습니다.")
            })
        } else {
          setSvgRaw("")
          setSvgNodes([])
          setEdges([])
          setError("해당 건물/층의 맵 파일을 찾을 수 없습니다.")
        }
      })
      .catch(() => {
        setSvgRaw("")
        setSvgNodes([])
        setEdges([])
        setError("맵 데이터를 불러오지 못했습니다.")
      })
      .finally(() => setLoading(false))
  }, [building, floor])

  return (
    <div 
      className={`${styles["room-root"]} ${styles["edit-page-root"]}`}
      style={{
        margin: 0,
        padding: 0,
        width: '100vw',
        height: '100vh',
        background: '#f4f7fc',
        overflow: 'hidden',
        position: 'fixed',
        top: 0,
        left: 0
      }}
    >
      <Menu menuOpen={menuOpen} setMenuOpen={setMenuOpen} />
      <span className={styles["room-header"]}>도면 편집 페이지</span>
      {building && floor && (
        <div
          style={{
            width: "100%",
            fontSize: 16,
            color: "#2574f5",
            fontWeight: 600,
            marginBottom: 12,
            textAlign: "center",
            whiteSpace: "nowrap",
            overflow: "hidden",
          }}
        >
          건물명: {building} / 층수: {floor}
        </div>
      )}
      <div className={styles["room-content"]}>
        <div className={styles["room-manage-map-wrap"]} style={{ position: "relative" }}>
          {/* 툴바 */}
          <div className={styles["edit-toolbar"]}>
            <button
              onClick={() => setShowNodeModal(true)}
              className={`${styles["toolbar-btn"]} ${styles["node-btn"]}`}
              title="노드 추가"
            >
              <div className={styles["toolbar-circle"]}></div>
            </button>
            <button
              onClick={() => setShowCategoryModal(true)}
              className={`${styles["toolbar-btn"]} ${styles["category-btn"]}`}
              title="카테고리 추가"
            >
              <div className={styles["toolbar-circle"]}></div>
            </button>
          </div>
          
          <div style={{ textAlign: "right", marginBottom: "8px" }}>
            {(pendingNodes.length > 0 || pendingCategories.length > 0) && (
              <button
                onClick={handleSaveSvg}
                style={{
                  padding: "6px 14px",
                  fontSize: "14px",
                  fontWeight: "bold",
                  color: "#fff",
                  backgroundColor: "#28a745",
                  border: "none",
                  borderRadius: "6px",
                  cursor: "pointer",
                  marginRight: "8px"
                }}
              >
                수정 완료 ({pendingNodes.length}개 노드, {pendingCategories.length}개 카테고리)
              </button>
            )}
            <button
              onClick={() => router.back()}
              style={{
                padding: "6px 14px",
                fontSize: "14px",
                fontWeight: "bold",
                color: "#fff",
                backgroundColor: "#2574f5",
                border: "none",
                borderRadius: "6px",
                cursor: "pointer",
                marginRight: "8px"
              }}
            >
              뒤로가기
            </button>
          </div>
          <div
            style={{ position: "relative", width: CANVAS_WIDTH, height: CANVAS_HEIGHT, border: "1px solid #ddd", backgroundColor: "#f8f9fa", overflow: "hidden" }}
          >
            {loading && (
              <div className={styles["room-manage-canvas-placeholder"]}>맵 로딩 중...</div>
            )}
            {!loading && (!building || !floor) && (
              <div className={styles["room-manage-canvas-placeholder"]}>URL의 building/floor 파라미터가 필요합니다.</div>
            )}
            {!loading && building && floor && !svgRaw && (
              <div className={styles["room-manage-canvas-placeholder"]}>{error || "해당 건물/층의 맵 파일을 찾을 수 없습니다."}</div>
            )}

            {!loading && building && floor && svgRaw && (() => {
              const scale = Math.min(CANVAS_WIDTH / svgViewBox.width, CANVAS_HEIGHT / svgViewBox.height)
              const offsetX = (CANVAS_WIDTH - svgViewBox.width * scale) / 2
              const offsetY = (CANVAS_HEIGHT - svgViewBox.height * scale) / 2

              return (
                <div
                  ref={mapContainerRef}
                  onClick={handleMapClick}
                  style={{
                    width: svgViewBox.width,
                    height: svgViewBox.height,
                    transform: `translate(${offsetX}px, ${offsetY}px) scale(${scale})`,
                    transformOrigin: "top left",
                    position: "relative",
                    cursor: isAddingMode ? "crosshair" : "default",
                  }}
                >
                  <div
                    style={{ position: "absolute", top: 0, left: 0, width: "100%", height: "100%" }}
                    dangerouslySetInnerHTML={{ __html: svgRaw }}
                  />


                  {/* 기존 노드들 */}
                  {svgNodes.map((node, index) => (
                    <div
                      key={`node-overlay-${node.id}-${index}`}
                      style={{
                        position: "absolute",
                        left: `${node.x - node.width / 2}px`,
                        top: `${node.y - node.height / 2}px`,
                        width: `${node.width}px`,
                        height: `${node.height}px`,
                        border: "1px solid #007bff",
                        backgroundColor: "rgba(0, 123, 255, 0.08)",
                        borderRadius: 4,
                      }}
                      title={`ID: ${node.id}`}
                    />
                  ))}
                  
                  {/* 임시로 추가된 노드들 */}
                  {pendingNodes.map((node, index) => (
                    <div
                      key={`pending-node-${node.id}-${index}`}
                      style={{
                        position: "absolute",
                        left: `${node.x - node.width / 2}px`,
                        top: `${node.y - node.height / 2}px`,
                        width: `${node.width}px`,
                        height: `${node.height}px`,
                        border: "1px solid #ff6b6b",
                        backgroundColor: "rgba(255, 107, 107, 0.1)",
                        borderRadius: "50%",
                        animation: "pulse 1.5s infinite",
                      }}
                      title={`새 노드: ${node.id}`}
                    />
                  ))}

                  {/* 임시로 추가된 카테고리들 */}
                  {pendingCategories.map((category, index) => (
                    <div
                      key={`pending-category-${category.id}-${index}`}
                      style={{
                        position: "absolute",
                        left: `${category.x - category.width / 2}px`,
                        top: `${category.y - category.height / 2}px`,
                        width: `${category.width}px`,
                        height: `${category.height}px`,
                        border: "1px solid #4ecdc4",
                        backgroundColor: "rgba(78, 205, 196, 0.1)",
                        borderRadius: "50%",
                        animation: "pulse 1.5s infinite",
                      }}
                      title={`새 카테고리: ${category.id}`}
                    />
                  ))}
                </div>
              )
            })()}
          </div>
        </div>
      </div>

      {/* 노드 추가 모달 */}
      {showNodeModal && (
        <div className={styles["modal-overlay"]} onClick={() => setShowNodeModal(false)}>
          <div className={styles["node-modal-content"]} onClick={(e) => e.stopPropagation()}>
            {/* 제목 */}
            <div className={styles["node-modal-title"]}>
              <h3>노드 추가</h3>
              <div className={styles["title-underline"]}></div>
            </div>

            {/* 라디오 버튼 선택 */}
            <div className={styles["node-type-selection"]}>
              <label className={styles["radio-option"]}>
                <input
                  type="radio"
                  name="nodeType"
                  value="stairs"
                  checked={nodeType === "stairs"}
                  onChange={(e) => setNodeType(e.target.value)}
                />
                <span className={styles["radio-custom"]}></span>
                계단
              </label>
              <label className={styles["radio-option"]}>
                <input
                  type="radio"
                  name="nodeType"
                  value="normal"
                  checked={nodeType === "normal"}
                  onChange={(e) => setNodeType(e.target.value)}
                />
                <span className={styles["radio-custom"]}></span>
                노드
              </label>
            </div>

            {/* 자동 생성 노드명 표시 */}
            {nodeType === "normal" && (
              <div className={styles["auto-generated-name"]}>
                자동 생성 노드명: {autoGeneratedName}
              </div>
            )}

            {/* 입력 필드 */}
            {nodeType === "stairs" && (
              <div className={styles["input-fields"]}>
                <input
                  type="text"
                  value={newNodeName}
                  onChange={(e) => setNewNodeName(e.target.value)}
                  placeholder="노드명"
                  className={styles["name-input"]}
                />
              </div>
            )}

            {/* 액션 버튼들 */}
            <div className={styles["modal-actions"]}>
              <button
                onClick={() => setShowNodeModal(false)}
                className={styles["cancel-btn"]}
              >
                취소
              </button>
              <button
                onClick={handleAddNode}
                className={styles["save-btn"]}
              >
                저장
              </button>
            </div>
          </div>
        </div>
      )}

      {/* 카테고리 추가 모달 */}
      {showCategoryModal && (
        <div className={styles["modal-overlay"]} onClick={() => setShowCategoryModal(false)}>
          <div className={styles["node-modal-content"]} onClick={(e) => e.stopPropagation()}>
            {/* 제목 */}
            <div className={styles["node-modal-title"]}>
              <h3>카테고리 추가</h3>
              <div className={styles["title-underline"]}></div>
            </div>

            {/* 카테고리 선택 */}
            <div className={styles["input-fields"]}>
              <select
                value={selectedCategory}
                onChange={(e) => setSelectedCategory(e.target.value)}
                className={styles["category-select"]}
              >
                <option value="">카테고리를 선택하세요</option>
                {categoryOptions.map((category) => (
                  <option key={category} value={category}>
                    {category}
                  </option>
                ))}
              </select>
            </div>

            {/* 액션 버튼들 */}
            <div className={styles["modal-actions"]}>
              <button
                onClick={() => setShowCategoryModal(false)}
                className={styles["cancel-btn"]}
              >
                취소
              </button>
              <button
                onClick={handleAddCategory}
                className={styles["save-btn"]}
              >
                저장
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
