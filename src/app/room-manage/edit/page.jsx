// room-manage/edit
"use client"
import React, { useEffect, useRef, useState } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import styles from "../room-manage.module.css"

export default function RoomManageEditPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const building = searchParams.get("building") || ""
  const floor = searchParams.get("floor") || ""

  const [svgRaw, setSvgRaw] = useState("")
  const [svgViewBox, setSvgViewBox] = useState({ x: 0, y: 0, width: 400, height: 400 })
  const [edges, setEdges] = useState([])
  const [svgNodes, setSvgNodes] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState("")
  const [showNodeModal, setShowNodeModal] = useState(false)
  const [showCategoryModal, setShowCategoryModal] = useState(false)
  const [newNodeName, setNewNodeName] = useState("")
  const [newCategoryName, setNewCategoryName] = useState("")
  const [selectedCategory, setSelectedCategory] = useState("")
  const [nodeType, setNodeType] = useState("stairs") // "stairs" or "normal"
  const [autoGeneratedName, setAutoGeneratedName] = useState("")
  const [nodeCounter, setNodeCounter] = useState(1)
  const [pendingNodes, setPendingNodes] = useState([]) // ì„ì‹œë¡œ ì¶”ê°€ëœ ë…¸ë“œë“¤
  const [isAddingMode, setIsAddingMode] = useState(false) // ë…¸ë“œ ì¶”ê°€ ëª¨ë“œ
  const [pendingCategories, setPendingCategories] = useState([]) // ì„ì‹œë¡œ ì¶”ê°€ëœ ì¹´í…Œê³ ë¦¬ë“¤
  const [isAddingCategoryMode, setIsAddingCategoryMode] = useState(false) // ì¹´í…Œê³ ë¦¬ ì¶”ê°€ ëª¨ë“œ

  const CANVAS_WIDTH = 1000
  const CANVAS_HEIGHT = 700
  const mapContainerRef = useRef(null)

  // ì¹´í…Œê³ ë¦¬ í•œê¸€-ì˜ì–´ ë§¤í•‘
  const categoryNameMap = {
    cafe: "ì¹´í˜",
    restaurant: "ì‹ë‹¹",
    convenience: "í¸ì˜ì ",
    vending: "ìíŒê¸°",
    water_purifier: "ì •ìˆ˜ê¸°",
    printer: "í”„ë¦°í„°",
    lounge: "ë¼ìš´ì§€",
    bank: "ì€í–‰(atm)",
    fire_extinguisher: "ì†Œí™”ê¸°",
    gym: "í—¬ìŠ¤ì¥",
    bookstore: "ì„œì ",
    post: "ìš°ì²´êµ­",
  }

  // ë¯¸ë¦¬ ì •ì˜ëœ ì¹´í…Œê³ ë¦¬ ëª©ë¡ (í•œê¸€ í‘œì‹œìš©)
  const categoryOptions = Object.values(categoryNameMap)

  // ìë™ ìƒì„± ë…¸ë“œëª… ì—…ë°ì´íŠ¸
  useEffect(() => {
    if (nodeType === "normal") {
      setAutoGeneratedName(`b${nodeCounter}`)
    }
  }, [nodeType, nodeCounter])

  // ë„ë©´ í´ë¦­ í•¸ë“¤ëŸ¬
  const handleMapClick = (event) => {
    if (!isAddingMode && !isAddingCategoryMode) return

    // SVG ì»¨í…Œì´ë„ˆì˜ ì‹¤ì œ í¬ê¸°ì™€ ìœ„ì¹˜ ê°€ì ¸ì˜¤ê¸°
    const containerRect = mapContainerRef.current.getBoundingClientRect()
    const scale = Math.min(CANVAS_WIDTH / svgViewBox.width, CANVAS_HEIGHT / svgViewBox.height)
    const offsetX = (CANVAS_WIDTH - svgViewBox.width * scale) / 2
    const offsetY = (CANVAS_HEIGHT - svgViewBox.height * scale) / 2

    // í´ë¦­í•œ ìœ„ì¹˜ë¥¼ SVG ì¢Œí‘œê³„ë¡œ ë³€í™˜ (ë” ê°„ë‹¨í•œ ë°©ë²•)
    const relativeX = event.clientX - containerRect.left
    const relativeY = event.clientY - containerRect.top
    
    // SVG ì»¨í…Œì´ë„ˆ ë‚´ì—ì„œì˜ ë¹„ìœ¨ ê³„ì‚°
    const clickX = (relativeX / containerRect.width) * svgViewBox.width
    const clickY = (relativeY / containerRect.height) * svgViewBox.height

    // ğŸ¯ í´ë¦­ ì¢Œí‘œ ë³€í™˜ ìƒì„¸ ë¡œê·¸
    console.log("=== í´ë¦­ ì¢Œí‘œ ë³€í™˜ ===")
    console.log("ë§ˆìš°ìŠ¤ í´ë¦­ ìœ„ì¹˜:", {
      clientX: event.clientX,
      clientY: event.clientY
    })
    console.log("ì»¨í…Œì´ë„ˆ ì •ë³´:", {
      left: containerRect.left,
      top: containerRect.top,
      width: containerRect.width,
      height: containerRect.height
    })
    console.log("SVG ë·°ë°•ìŠ¤:", svgViewBox)
    console.log("ìŠ¤ì¼€ì¼ ê³„ì‚°:", {
      scale,
      offsetX,
      offsetY
    })
    console.log("ìµœì¢… ë³€í™˜ëœ ì¢Œí‘œ:", {
      clickX: clickX,
      clickY: clickY
    })
    console.log("=========================")

    if (isAddingMode) {
      // ë…¸ë“œ ì¶”ê°€ ëª¨ë“œ
      const newNodeId = nodeType === "stairs" ? newNodeName.trim() : `b${nodeCounter}`
      const newNode = {
        id: `${building}@${floor}@${newNodeId}`,
        x: clickX,
        y: clickY,
        width: 8, // ê¸°ì¡´ ë…¸ë“œë“¤ê³¼ ë¹„ìŠ·í•œ í¬ê¸°
        height: 8, // ê¸°ì¡´ ë…¸ë“œë“¤ê³¼ ë¹„ìŠ·í•œ í¬ê¸°
        element: "circle",
        layer: "Navigation_Nodes",
        nodeType: nodeType,
        isPending: true
      }

      // ğŸ“ ìƒˆ ë…¸ë“œ ì¶”ê°€ ë¡œê·¸
      console.log("=== ìƒˆ ë…¸ë“œ ì¶”ê°€ ===")
      console.log("ë…¸ë“œ ID:", newNode.id)
      console.log("ë…¸ë“œ ì¢Œí‘œ:", { x: newNode.x, y: newNode.y })
      console.log("ë…¸ë“œ íƒ€ì…:", newNode.nodeType)
      console.log("ë…¸ë“œ í¬ê¸°:", { width: newNode.width, height: newNode.height })
      console.log("===================")

      setPendingNodes(prev => [...prev, newNode])
      
      // ì¼ë°˜ ë…¸ë“œì¸ ê²½ìš° ì¹´ìš´í„° ì¦ê°€
      if (nodeType === "normal") {
        setNodeCounter(prev => prev + 1)
      }

      // ëª¨ë‹¬ ë‹«ê¸°
      setShowNodeModal(false)
      setIsAddingMode(false)
    } else if (isAddingCategoryMode) {
      // ì¹´í…Œê³ ë¦¬ ì¶”ê°€ ëª¨ë“œ
      const englishCategoryName = Object.keys(categoryNameMap).find(
        key => categoryNameMap[key] === selectedCategory
      )
      
      const newCategory = {
        id: `${building}@${floor}@${englishCategoryName}`,
        x: clickX,
        y: clickY,
        width: 8,
        height: 8,
        element: "circle",
        layer: "Categories",
        categoryType: englishCategoryName,
        isPending: true
      }

      // ğŸ·ï¸ ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€ ë¡œê·¸
      console.log("=== ìƒˆ ì¹´í…Œê³ ë¦¬ ì¶”ê°€ ===")
      console.log("ì¹´í…Œê³ ë¦¬ ID:", newCategory.id)
      console.log("ì¹´í…Œê³ ë¦¬ ì¢Œí‘œ:", { x: newCategory.x, y: newCategory.y })
      console.log("ì¹´í…Œê³ ë¦¬ íƒ€ì…:", newCategory.categoryType)
      console.log("ì¹´í…Œê³ ë¦¬ í¬ê¸°:", { width: newCategory.width, height: newCategory.height })
      console.log("========================")

      setPendingCategories(prev => [...prev, newCategory])
      setShowCategoryModal(false)
      setIsAddingCategoryMode(false)
    }
  }

  function parseNodeInfo(fullId) {
    const parts = (fullId || "").split("@")
    if (parts.length < 3) return { building: "", floor: "", node: "" }
    return { building: parts[0], floor: parts[1], node: parts[2] }
  }

  const handleAddNode = () => {
    // ê³„ë‹¨ì¸ ê²½ìš° ë…¸ë“œ ì´ë¦„ì´ í•„ìš”
    if (nodeType === "stairs" && !newNodeName.trim()) {
      alert("ë…¸ë“œëª…ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.")
      return
    }
    
    // ë…¸ë“œ ì¶”ê°€ ëª¨ë“œë¡œ ì „í™˜
    setIsAddingMode(true)
    setShowNodeModal(false)
    alert("ë„ë©´ì—ì„œ ë…¸ë“œë¥¼ ì¶”ê°€í•  ìœ„ì¹˜ë¥¼ í´ë¦­í•´ì£¼ì„¸ìš”.")
  }

  // ìˆ˜ì • ì™„ë£Œ í•¨ìˆ˜
  const handleSaveChanges = async () => {
    if (pendingNodes.length === 0 && pendingCategories.length === 0) {
      alert("ì¶”ê°€ëœ ë…¸ë“œë‚˜ ì¹´í…Œê³ ë¦¬ê°€ ì—†ìŠµë‹ˆë‹¤.")
      return
    }

    try {
      // ğŸ“Š ìˆ˜ì •ëœ SVG ìƒì„± ë° ë¡œê·¸
      console.log("=== ë„ë©´ í¸ì§‘ SVG ìˆ˜ì • ===")
      console.log("ê±´ë¬¼ëª…:", building)
      console.log("ì¸µìˆ˜:", floor)
      console.log("ì¶”ê°€í•  ë…¸ë“œ ê°œìˆ˜:", pendingNodes.length)
      console.log("ì¶”ê°€í•  ì¹´í…Œê³ ë¦¬ ê°œìˆ˜:", pendingCategories.length)
      
      // ğŸ“ ë…¸ë“œ ì¢Œí‘œ ìƒì„¸ ë¡œê·¸
      console.log("--- ì¶”ê°€í•  ë…¸ë“œë“¤ ---")
      pendingNodes.forEach((node, index) => {
        console.log(`ë…¸ë“œ ${index + 1}:`, {
          id: node.id,
          x: node.x,
          y: node.y,
          width: node.width,
          height: node.height,
          element: node.element,
          layer: node.layer,
          nodeType: node.nodeType
        })
      })
      
      // ğŸ·ï¸ ì¹´í…Œê³ ë¦¬ ì¢Œí‘œ ìƒì„¸ ë¡œê·¸
      console.log("--- ì¶”ê°€í•  ì¹´í…Œê³ ë¦¬ë“¤ ---")
      pendingCategories.forEach((category, index) => {
        console.log(`ì¹´í…Œê³ ë¦¬ ${index + 1}:`, {
          id: category.id,
          x: category.x,
          y: category.y,
          width: category.width,
          height: category.height,
          element: category.element,
          layer: category.layer,
          categoryType: category.categoryType
        })
      })

      // SVG íŒŒì¼ì— ë…¸ë“œì™€ ì¹´í…Œê³ ë¦¬ ì¶”ê°€
      const modifiedSvg = addNodesToSvg(svgRaw, pendingNodes, pendingCategories)
      
      console.log("--- ìˆ˜ì •ëœ SVG íŒŒì¼ ê²€ì¦ ---")
      console.log("SVG ë‚´ìš© ê¸¸ì´:", modifiedSvg.length, "characters")
      
      // ğŸ” ìˆ˜ì •ëœ SVG íŒŒì¼ì— ì‹¤ì œë¡œ ë…¸ë“œê°€ í¬í•¨ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸
      if (modifiedSvg.includes('Navigation_Nodes')) {
        console.log("âœ… SVGì— Navigation_Nodes ë ˆì´ì–´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.")
        const nodeMatches = modifiedSvg.match(/<circle[^>]*>/g) || []
        console.log("âœ… SVGì— í¬í•¨ëœ circle ìš”ì†Œ ê°œìˆ˜:", nodeMatches.length)
      } else {
        console.log("âŒ SVGì— Navigation_Nodes ë ˆì´ì–´ê°€ ì—†ìŠµë‹ˆë‹¤!")
      }
      
      if (modifiedSvg.includes('Categories')) {
        console.log("âœ… SVGì— Categories ë ˆì´ì–´ê°€ í¬í•¨ë˜ì–´ ìˆìŠµë‹ˆë‹¤.")
      } else {
        console.log("âŒ SVGì— Categories ë ˆì´ì–´ê°€ ì—†ìŠµë‹ˆë‹¤!")
      }
      
      // ìˆ˜ì •ëœ SVGì˜ Navigation_Nodes ë¶€ë¶„ë§Œ ì¶”ì¶œí•´ì„œ í™•ì¸
      const navNodesMatch = modifiedSvg.match(/<g[^>]*id="Navigation_Nodes"[^>]*>.*?<\/g>/s)
      if (navNodesMatch) {
        console.log("Navigation_Nodes ë ˆì´ì–´ ë‚´ìš©:", navNodesMatch[0])
      }
      
      // ìˆ˜ì •ëœ SVGì˜ Categories ë¶€ë¶„ë§Œ ì¶”ì¶œí•´ì„œ í™•ì¸
      const categoriesMatch = modifiedSvg.match(/<g[^>]*id="Categories"[^>]*>.*?<\/g>/s)
      if (categoriesMatch) {
        console.log("Categories ë ˆì´ì–´ ë‚´ìš©:", categoriesMatch[0])
      }

      // ğŸ“ ìˆ˜ì •ëœ SVG íŒŒì¼ ë‹¤ìš´ë¡œë“œ ê¸°ëŠ¥
      const downloadSvg = () => {
        const blob = new Blob([modifiedSvg], { type: 'image/svg+xml' })
        const url = URL.createObjectURL(blob)
        const a = document.createElement('a')
        a.href = url
        a.download = `${building}_${floor}_modified.svg`
        document.body.appendChild(a)
        a.click()
        document.body.removeChild(a)
        URL.revokeObjectURL(url)
      }

      // ğŸ” ìˆ˜ì •ëœ SVGë¥¼ ìƒˆ ì°½ì—ì„œ ë¯¸ë¦¬ë³´ê¸°
      const previewSvg = () => {
        const newWindow = window.open('', '_blank')
        newWindow.document.write(`
          <html>
            <head>
              <title>ìˆ˜ì •ëœ SVG ë¯¸ë¦¬ë³´ê¸° - ${building} ${floor}</title>
              <style>
                body { margin: 0; padding: 20px; background: #f5f5f5; }
                .preview-container { 
                  background: white; 
                  border-radius: 8px; 
                  padding: 20px; 
                  box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                  max-width: 1200px;
                  margin: 0 auto;
                }
                h1 { color: #333; margin-bottom: 20px; }
                .info { 
                  background: #e3f2fd; 
                  padding: 15px; 
                  border-radius: 6px; 
                  margin-bottom: 20px;
                  border-left: 4px solid #2196f3;
                }
                svg { 
                  max-width: 100%; 
                  height: auto; 
                  border: 1px solid #ddd; 
                  background: white;
                }
              </style>
            </head>
            <body>
              <div class="preview-container">
                <h1>ìˆ˜ì •ëœ SVG ë¯¸ë¦¬ë³´ê¸°</h1>
                <div class="info">
                  <strong>ê±´ë¬¼:</strong> ${building}<br>
                  <strong>ì¸µìˆ˜:</strong> ${floor}<br>
                  <strong>ì¶”ê°€ëœ ë…¸ë“œ:</strong> ${pendingNodes.length}ê°œ<br>
                  <strong>ì¶”ê°€ëœ ì¹´í…Œê³ ë¦¬:</strong> ${pendingCategories.length}ê°œ
                </div>
                ${modifiedSvg}
              </div>
            </body>
          </html>
        `)
        newWindow.document.close()
      }

      // ì‚¬ìš©ìì—ê²Œ ì„ íƒ ì˜µì…˜ ì œê³µ
      const userChoice = confirm(
        `ìˆ˜ì •ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!\n\n` +
        `ì¶”ê°€ëœ ë…¸ë“œ: ${pendingNodes.length}ê°œ\n` +
        `ì¶”ê°€ëœ ì¹´í…Œê³ ë¦¬: ${pendingCategories.length}ê°œ\n\n` +
        `í™•ì¸ ë°©ë²•ì„ ì„ íƒí•˜ì„¸ìš”:\n` +
        `â€¢ í™•ì¸: ìƒˆ ì°½ì—ì„œ ë¯¸ë¦¬ë³´ê¸°\n` +
        `â€¢ ì·¨ì†Œ: SVG íŒŒì¼ ë‹¤ìš´ë¡œë“œ`
      )

      if (userChoice) {
        previewSvg()
      } else {
        downloadSvg()
      }

      // ìƒíƒœ ì´ˆê¸°í™”
      setPendingNodes([])
      setPendingCategories([])
      setNewNodeName("")
      setSelectedCategory("")
      setNodeType("stairs")
      setAutoGeneratedName("")

    } catch (error) {
      console.error("=== SVG ìˆ˜ì • ì˜¤ë¥˜ ===")
      console.error("ì˜¤ë¥˜ íƒ€ì…:", error.name)
      console.error("ì˜¤ë¥˜ ë©”ì‹œì§€:", error.message)
      console.error("ì˜¤ë¥˜ ìŠ¤íƒ:", error.stack)
      alert("SVG ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.")
    }
  }

  // SVGì— ë…¸ë“œ ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜
  const addNodesToSvg = (svgXml, nodes, categories = []) => {
    console.log("=== SVG ë…¸ë“œ ì¶”ê°€ ì‹œì‘ ===")
    console.log("ì¶”ê°€í•  ë…¸ë“œ ê°œìˆ˜:", nodes.length)
    console.log("ì¶”ê°€í•  ì¹´í…Œê³ ë¦¬ ê°œìˆ˜:", categories.length)
    
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    
    let navigationLayer = doc.querySelector('g[id="Navigation_Nodes"]') ||
                         doc.querySelector('g[id="navigation_nodes"]') ||
                         doc.querySelector('g[id="Navigation_nodes"]') ||
                         doc.querySelector('g[id="navigation-nodes"]')

    // Navigation_Nodes ë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ìƒì„±
    if (!navigationLayer) {
      console.log("Navigation_Nodes ë ˆì´ì–´ê°€ ì—†ì–´ì„œ ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.")
      navigationLayer = doc.createElementNS("http://www.w3.org/2000/svg", "g")
      navigationLayer.setAttribute("id", "Navigation_Nodes")
      doc.querySelector("svg").appendChild(navigationLayer)
    } else {
      console.log("ê¸°ì¡´ Navigation_Nodes ë ˆì´ì–´ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.")
    }

    // Categories ë ˆì´ì–´ ì°¾ê¸°
    let categoriesLayer = doc.querySelector('g[id="Categories"]') ||
                         doc.querySelector('g[id="categories"]') ||
                         doc.querySelector('g[id="Category"]') ||
                         doc.querySelector('g[id="category"]')

    // Categories ë ˆì´ì–´ê°€ ì—†ìœ¼ë©´ ìƒì„±
    if (!categoriesLayer) {
      console.log("Categories ë ˆì´ì–´ê°€ ì—†ì–´ì„œ ìƒˆë¡œ ìƒì„±í•©ë‹ˆë‹¤.")
      categoriesLayer = doc.createElementNS("http://www.w3.org/2000/svg", "g")
      categoriesLayer.setAttribute("id", "Categories")
      doc.querySelector("svg").appendChild(categoriesLayer)
    } else {
      console.log("ê¸°ì¡´ Categories ë ˆì´ì–´ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.")
    }

    // ê° ë…¸ë“œë¥¼ SVG ìš”ì†Œë¡œ ì¶”ê°€ (ê¸°ì¡´ ë…¸ë“œì™€ ë™ì¼í•œ ìŠ¤íƒ€ì¼)
    nodes.forEach((node, index) => {
      const nodeId = node.id.split("@")[2] // building@floor@nodeIdì—ì„œ nodeIdë§Œ ì¶”ì¶œ
      
      console.log(`ë…¸ë“œ ${index + 1} SVG ì¶”ê°€:`, {
        nodeId,
        cx: node.x,
        cy: node.y,
        r: "2.1957438"
      })
      
      const circle = doc.createElementNS("http://www.w3.org/2000/svg", "circle")
      circle.setAttribute("id", nodeId)
      circle.setAttribute("cx", node.x)
      circle.setAttribute("cy", node.y)
      circle.setAttribute("r", "2.1957438") // ê¸°ì¡´ ë…¸ë“œì™€ ë™ì¼í•œ ë°˜ì§€ë¦„
      circle.setAttribute("style", "fill:#00ffff;fill-opacity:0;stroke:#ffffff;stroke-width:0") // ê¸°ì¡´ ë…¸ë“œì™€ ë™ì¼í•œ ìŠ¤íƒ€ì¼
      
      navigationLayer.appendChild(circle)
    })

    // ê° ì¹´í…Œê³ ë¦¬ë¥¼ SVG ìš”ì†Œë¡œ ì¶”ê°€ (ì¹´í…Œê³ ë¦¬ëŠ” íˆ¬ëª…í•˜ê²Œ ì„¤ì •)
    categories.forEach((category, index) => {
      const categoryId = category.id.split("@")[2] // building@floor@categoryIdì—ì„œ categoryIdë§Œ ì¶”ì¶œ
      
      console.log(`ì¹´í…Œê³ ë¦¬ ${index + 1} SVG ì¶”ê°€:`, {
        categoryId,
        cx: category.x,
        cy: category.y,
        r: "2.1957438"
      })
      
      const circle = doc.createElementNS("http://www.w3.org/2000/svg", "circle")
      circle.setAttribute("id", categoryId)
      circle.setAttribute("cx", category.x)
      circle.setAttribute("cy", category.y)
      circle.setAttribute("r", "2.1957438") // ê¸°ì¡´ ë…¸ë“œì™€ ë™ì¼í•œ ë°˜ì§€ë¦„
      circle.setAttribute("style", "fill:#ff6b6b;fill-opacity:0;stroke:#ff6b6b;stroke-opacity:0;stroke-width:0") // ì¹´í…Œê³ ë¦¬ëŠ” ì™„ì „ íˆ¬ëª…í•˜ê²Œ ì„¤ì •
      
      categoriesLayer.appendChild(circle)
    })

    const result = doc.documentElement.outerHTML
    
    // ğŸ” SVG ìˆ˜ì • ê²°ê³¼ ìƒì„¸ í™•ì¸
    console.log("SVG ìˆ˜ì • ì™„ë£Œ. ìµœì¢… SVG ê¸¸ì´:", result.length, "characters")
    
    // Navigation_Nodes ë ˆì´ì–´ì— ì‹¤ì œë¡œ ë…¸ë“œê°€ ì¶”ê°€ë˜ì—ˆëŠ”ì§€ í™•ì¸
    const finalNavigationLayer = doc.querySelector('g[id="Navigation_Nodes"]')
    if (finalNavigationLayer) {
      const addedNodes = finalNavigationLayer.querySelectorAll('circle')
      console.log("Navigation_Nodes ë ˆì´ì–´ì— ì¶”ê°€ëœ ë…¸ë“œ ê°œìˆ˜:", addedNodes.length)
      addedNodes.forEach((node, index) => {
        console.log(`ì¶”ê°€ëœ ë…¸ë“œ ${index + 1}:`, {
          id: node.getAttribute('id'),
          cx: node.getAttribute('cx'),
          cy: node.getAttribute('cy'),
          r: node.getAttribute('r'),
          style: node.getAttribute('style')
        })
      })
    }
    
    // Categories ë ˆì´ì–´ì— ì‹¤ì œë¡œ ì¹´í…Œê³ ë¦¬ê°€ ì¶”ê°€ë˜ì—ˆëŠ”ì§€ í™•ì¸
    const finalCategoriesLayer = doc.querySelector('g[id="Categories"]')
    if (finalCategoriesLayer) {
      const addedCategories = finalCategoriesLayer.querySelectorAll('circle')
      console.log("Categories ë ˆì´ì–´ì— ì¶”ê°€ëœ ì¹´í…Œê³ ë¦¬ ê°œìˆ˜:", addedCategories.length)
      addedCategories.forEach((category, index) => {
        console.log(`ì¶”ê°€ëœ ì¹´í…Œê³ ë¦¬ ${index + 1}:`, {
          id: category.getAttribute('id'),
          cx: category.getAttribute('cx'),
          cy: category.getAttribute('cy'),
          r: category.getAttribute('r'),
          style: category.getAttribute('style')
        })
      })
    }
    
    // ğŸ” ìˆ˜ì •ëœ SVGì˜ ì¼ë¶€ ë‚´ìš© í™•ì¸ (ì²˜ìŒ 500ì)
    console.log("ìˆ˜ì •ëœ SVG ì‹œì‘ ë¶€ë¶„:", result.substring(0, 500))
    console.log("=== SVG ë…¸ë“œ ì¶”ê°€ ì™„ë£Œ ===")
    
    return result
  }

  const handleAddCategory = () => {
    if (!selectedCategory) {
      alert("ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.")
      return
    }

    // ì¹´í…Œê³ ë¦¬ ì¶”ê°€ ëª¨ë“œë¡œ ì „í™˜
    setIsAddingCategoryMode(true)
    setShowCategoryModal(false)
    alert("ë„ë©´ì—ì„œ ì¹´í…Œê³ ë¦¬ë¥¼ ì¶”ê°€í•  ìœ„ì¹˜ë¥¼ í´ë¦­í•´ì£¼ì„¸ìš”.")
  }

  function processSvg(svgXml) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    const svgEl = doc.querySelector("svg")
    if (!svgEl) return svgXml

    const existingViewBox = svgEl.getAttribute("viewBox")
    if (existingViewBox) {
      const parts = existingViewBox.split(/[\s,]+/).map(Number)
      if (parts.length === 4) {
        setSvgViewBox({ x: parts[0], y: parts[1], width: parts[2], height: parts[3] })
        return svgXml
      }
    }

    const width = parseFloat(svgEl.getAttribute("width")) || 400
    const height = parseFloat(svgEl.getAttribute("height")) || 400
    const viewBoxStr = `0 0 ${width} ${height}`
    svgEl.setAttribute("viewBox", viewBoxStr)
    setSvgViewBox({ x: 0, y: 0, width, height })
    svgEl.removeAttribute("width")
    svgEl.removeAttribute("height")

    return doc.documentElement.outerHTML
  }

  function parseSvgNodes(svgXml, buildingName, floorName) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    const nodes = []

    const navigationLayer =
      doc.querySelector('g[id="Navigation_Nodes"]') ||
      doc.querySelector('g[id="navigation_nodes"]') ||
      doc.querySelector('g[id="Navigation_nodes"]') ||
      doc.querySelector('g[id="navigation-nodes"]')

    if (!navigationLayer) {
      return []
    }

    const allElements = navigationLayer.querySelectorAll("*[id]")
    allElements.forEach((element) => {
      const nodeSuffix = element.getAttribute("id")
      if (!nodeSuffix) return
      const fullNodeId = `${buildingName}@${floorName}@${nodeSuffix}`

      let x = 0, y = 0, width = 0, height = 0
      switch (element.tagName.toLowerCase()) {
        case "rect":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 0)
          height = parseFloat(element.getAttribute("height") || 0)
          break
        case "circle":
          x = parseFloat(element.getAttribute("cx") || 0)
          y = parseFloat(element.getAttribute("cy") || 0)
          width = height = parseFloat(element.getAttribute("r") || 0) * 2
          break
        case "ellipse":
          x = parseFloat(element.getAttribute("cx") || 0)
          y = parseFloat(element.getAttribute("cy") || 0)
          width = parseFloat(element.getAttribute("rx") || 0) * 2
          height = parseFloat(element.getAttribute("ry") || 0) * 2
          break
        case "line":
          x = parseFloat(element.getAttribute("x1") || 0)
          y = parseFloat(element.getAttribute("y1") || 0)
          const x2 = parseFloat(element.getAttribute("x2") || 0)
          const y2 = parseFloat(element.getAttribute("y2") || 0)
          width = Math.abs(x2 - x)
          height = Math.abs(y2 - y)
          break
        case "polygon":
        case "polyline":
          const points = element.getAttribute("points") || ""
          const pointsArray = points.split(/[\s,]+/).filter((p) => p).map(Number)
          if (pointsArray.length >= 2) {
            const xCoords = pointsArray.filter((_, i) => i % 2 === 0)
            const yCoords = pointsArray.filter((_, i) => i % 2 === 1)
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "path":
          const d = element.getAttribute("d") || ""
          const matches = d.match(/[ML]\s*([0-9.-]+)\s*,?\s*([0-9.-]+)/g)
          if (matches && matches.length > 0) {
            const coords = matches.map((m) => {
              const nums = m.replace(/[ML]\s*/, "").split(/[\s,]+/).map(Number)
              return { x: nums[0] || 0, y: nums[1] || 0 }
            })
            const xCoords = coords.map((c) => c.x)
            const yCoords = coords.map((c) => c.y)
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "text":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = element.textContent ? element.textContent.length * 8 : 50
          height = 20
          break
        case "g":
          const transform = element.getAttribute("transform") || ""
          const translateMatch = transform.match(/translate\(([^)]+)\)/)
          if (translateMatch) {
            const translateValues = translateMatch[1].split(/[\s,]+/).map(Number)
            x = translateValues[0] || 0
            y = translateValues[1] || 0
          }
          width = height = 20
          break
        default:
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 20)
          height = parseFloat(element.getAttribute("height") || 20)
      }

      nodes.push({ id: fullNodeId, x, y, width, height, element: element.tagName.toLowerCase(), layer: "Navigation_Nodes" })
    })

    return nodes
  }

  useEffect(() => {
    if (!building || !floor) return

    setLoading(true)
    setError("")

    fetch(`/api/map-route?building=${encodeURIComponent(building)}&floor=${encodeURIComponent(floor)}`)
      .then((res) => res.json())
      .then((data) => {
        const fileList = Array.isArray(data) ? data : [data]
        const rawSvgUrl = fileList[0]?.File
        const nodesInfo = fileList[0]?.nodes || {}
        let edgesInfo = fileList[0]?.edges

        if (!edgesInfo) {
          edgesInfo = []
          Object.entries(nodesInfo).forEach(([from, arr]) => {
            arr.forEach((edgeObj) => {
              const to = typeof edgeObj === "string" ? edgeObj : (edgeObj.node || edgeObj.to)
              if (to) edgesInfo.push({ from, to })
            })
          })
        }

        if (rawSvgUrl) {
          const svgUrl = rawSvgUrl + (rawSvgUrl.includes("?") ? "&" : "?") + "ts=" + Date.now()
          setSvgRaw("")
          setSvgNodes([])
          setEdges([])

          fetch(svgUrl)
            .then((res) => res.text())
            .then((svgXml) => {
              const processedSvg = processSvg(svgXml)
              setSvgRaw(processedSvg)
              setEdges(edgesInfo)
              const parsedNodes = parseSvgNodes(svgXml, building, floor)
              setSvgNodes(parsedNodes)
            })
            .catch(() => {
              setSvgRaw("")
              setSvgNodes([])
              setEdges([])
              setError("ë„ë©´ì„ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
            })
        } else {
          setSvgRaw("")
          setSvgNodes([])
          setEdges([])
          setError("í•´ë‹¹ ê±´ë¬¼/ì¸µì˜ ë§µ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
        }
      })
      .catch(() => {
        setSvgRaw("")
        setSvgNodes([])
        setEdges([])
        setError("ë§µ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.")
      })
      .finally(() => setLoading(false))
  }, [building, floor])

  return (
    <div 
      className={`${styles["room-root"]} ${styles["edit-page-root"]}`}
      style={{
        margin: 0,
        padding: 0,
        width: '100vw',
        height: '100vh',
        background: '#f4f7fc',
        overflow: 'hidden',
        position: 'fixed',
        top: 0,
        left: 0
      }}
    >
      <span className={styles["room-header"]}>ë„ë©´ í¸ì§‘ í˜ì´ì§€</span>
      {building && floor && (
        <div
          style={{
            width: "100%",
            fontSize: 16,
            color: "#2574f5",
            fontWeight: 600,
            marginBottom: 12,
            textAlign: "center",
            whiteSpace: "nowrap",
            overflow: "hidden",
          }}
        >
          ê±´ë¬¼ëª…: {building} / ì¸µìˆ˜: {floor}
        </div>
      )}
      <div className={styles["room-content"]}>
        <div className={styles["room-manage-map-wrap"]} style={{ position: "relative" }}>
          {/* íˆ´ë°” */}
          <div className={styles["edit-toolbar"]}>
            <button
              onClick={() => setShowNodeModal(true)}
              className={`${styles["toolbar-btn"]} ${styles["node-btn"]}`}
              title="ë…¸ë“œ ì¶”ê°€"
            >
              <div className={styles["toolbar-circle"]}></div>
            </button>
            <button
              onClick={() => setShowCategoryModal(true)}
              className={`${styles["toolbar-btn"]} ${styles["category-btn"]}`}
              title="ì¹´í…Œê³ ë¦¬ ì¶”ê°€"
            >
              <div className={styles["toolbar-circle"]}></div>
            </button>
          </div>
          
          <div style={{ textAlign: "right", marginBottom: "8px" }}>
            {(pendingNodes.length > 0 || pendingCategories.length > 0) && (
              <button
                onClick={handleSaveChanges}
                style={{
                  padding: "6px 14px",
                  fontSize: "14px",
                  fontWeight: "bold",
                  color: "#fff",
                  backgroundColor: "#28a745",
                  border: "none",
                  borderRadius: "6px",
                  cursor: "pointer",
                  marginRight: "8px"
                }}
              >
                ìˆ˜ì • ì™„ë£Œ ({pendingNodes.length}ê°œ ë…¸ë“œ, {pendingCategories.length}ê°œ ì¹´í…Œê³ ë¦¬)
              </button>
            )}
            <button
              onClick={() => router.back()}
              style={{
                padding: "6px 14px",
                fontSize: "14px",
                fontWeight: "bold",
                color: "#fff",
                backgroundColor: "#2574f5",
                border: "none",
                borderRadius: "6px",
                cursor: "pointer",
                marginRight: "8px"
              }}
            >
              ë’¤ë¡œê°€ê¸°
            </button>
          </div>
          <div
            style={{ position: "relative", width: CANVAS_WIDTH, height: CANVAS_HEIGHT, border: "1px solid #ddd", backgroundColor: "#f8f9fa", overflow: "hidden" }}
          >
            {loading && (
              <div className={styles["room-manage-canvas-placeholder"]}>ë§µ ë¡œë”© ì¤‘...</div>
            )}
            {!loading && (!building || !floor) && (
              <div className={styles["room-manage-canvas-placeholder"]}>URLì˜ building/floor íŒŒë¼ë¯¸í„°ê°€ í•„ìš”í•©ë‹ˆë‹¤.</div>
            )}
            {!loading && building && floor && !svgRaw && (
              <div className={styles["room-manage-canvas-placeholder"]}>{error || "í•´ë‹¹ ê±´ë¬¼/ì¸µì˜ ë§µ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."}</div>
            )}

            {!loading && building && floor && svgRaw && (() => {
              const scale = Math.min(CANVAS_WIDTH / svgViewBox.width, CANVAS_HEIGHT / svgViewBox.height)
              const offsetX = (CANVAS_WIDTH - svgViewBox.width * scale) / 2
              const offsetY = (CANVAS_HEIGHT - svgViewBox.height * scale) / 2

              return (
                <div
                  ref={mapContainerRef}
                  onClick={handleMapClick}
                  style={{
                    width: svgViewBox.width,
                    height: svgViewBox.height,
                    transform: `translate(${offsetX}px, ${offsetY}px) scale(${scale})`,
                    transformOrigin: "top left",
                    position: "relative",
                    cursor: isAddingMode ? "crosshair" : "default",
                  }}
                >
                  <div
                    style={{ position: "absolute", top: 0, left: 0, width: "100%", height: "100%" }}
                    dangerouslySetInnerHTML={{ __html: svgRaw }}
                  />


                  {/* ê¸°ì¡´ ë…¸ë“œë“¤ */}
                  {svgNodes.map((node, index) => (
                    <div
                      key={`node-overlay-${node.id}-${index}`}
                      style={{
                        position: "absolute",
                        left: `${node.x - node.width / 2}px`,
                        top: `${node.y - node.height / 2}px`,
                        width: `${node.width}px`,
                        height: `${node.height}px`,
                        border: "1px solid #007bff",
                        backgroundColor: "rgba(0, 123, 255, 0.08)",
                        borderRadius: 4,
                      }}
                      title={`ID: ${node.id}`}
                    />
                  ))}
                  
                  {/* ì„ì‹œë¡œ ì¶”ê°€ëœ ë…¸ë“œë“¤ */}
                  {pendingNodes.map((node, index) => (
                    <div
                      key={`pending-node-${node.id}-${index}`}
                      style={{
                        position: "absolute",
                        left: `${node.x - node.width / 2}px`,
                        top: `${node.y - node.height / 2}px`,
                        width: `${node.width}px`,
                        height: `${node.height}px`,
                        border: "1px solid #ff6b6b",
                        backgroundColor: "rgba(255, 107, 107, 0.1)",
                        borderRadius: "50%",
                        animation: "pulse 1.5s infinite",
                      }}
                      title={`ìƒˆ ë…¸ë“œ: ${node.id}`}
                    />
                  ))}

                  {/* ì„ì‹œë¡œ ì¶”ê°€ëœ ì¹´í…Œê³ ë¦¬ë“¤ */}
                  {pendingCategories.map((category, index) => (
                    <div
                      key={`pending-category-${category.id}-${index}`}
                      style={{
                        position: "absolute",
                        left: `${category.x - category.width / 2}px`,
                        top: `${category.y - category.height / 2}px`,
                        width: `${category.width}px`,
                        height: `${category.height}px`,
                        border: "1px solid #4ecdc4",
                        backgroundColor: "rgba(78, 205, 196, 0.1)",
                        borderRadius: "50%",
                        animation: "pulse 1.5s infinite",
                      }}
                      title={`ìƒˆ ì¹´í…Œê³ ë¦¬: ${category.id}`}
                    />
                  ))}
                </div>
              )
            })()}
          </div>
        </div>
      </div>

      {/* ë…¸ë“œ ì¶”ê°€ ëª¨ë‹¬ */}
      {showNodeModal && (
        <div className={styles["modal-overlay"]} onClick={() => setShowNodeModal(false)}>
          <div className={styles["node-modal-content"]} onClick={(e) => e.stopPropagation()}>
            {/* ì œëª© */}
            <div className={styles["node-modal-title"]}>
              <h3>ë…¸ë“œ ì¶”ê°€</h3>
              <div className={styles["title-underline"]}></div>
            </div>

            {/* ë¼ë””ì˜¤ ë²„íŠ¼ ì„ íƒ */}
            <div className={styles["node-type-selection"]}>
              <label className={styles["radio-option"]}>
                <input
                  type="radio"
                  name="nodeType"
                  value="stairs"
                  checked={nodeType === "stairs"}
                  onChange={(e) => setNodeType(e.target.value)}
                />
                <span className={styles["radio-custom"]}></span>
                ê³„ë‹¨
              </label>
              <label className={styles["radio-option"]}>
                <input
                  type="radio"
                  name="nodeType"
                  value="normal"
                  checked={nodeType === "normal"}
                  onChange={(e) => setNodeType(e.target.value)}
                />
                <span className={styles["radio-custom"]}></span>
                ë…¸ë“œ
              </label>
            </div>

            {/* ìë™ ìƒì„± ë…¸ë“œëª… í‘œì‹œ */}
            {nodeType === "normal" && (
              <div className={styles["auto-generated-name"]}>
                ìë™ ìƒì„± ë…¸ë“œëª…: {autoGeneratedName}
              </div>
            )}

            {/* ì…ë ¥ í•„ë“œ */}
            {nodeType === "stairs" && (
              <div className={styles["input-fields"]}>
                <input
                  type="text"
                  value={newNodeName}
                  onChange={(e) => setNewNodeName(e.target.value)}
                  placeholder="ë…¸ë“œëª…"
                  className={styles["name-input"]}
                />
              </div>
            )}

            {/* ì•¡ì…˜ ë²„íŠ¼ë“¤ */}
            <div className={styles["modal-actions"]}>
              <button
                onClick={() => setShowNodeModal(false)}
                className={styles["cancel-btn"]}
              >
                ì·¨ì†Œ
              </button>
              <button
                onClick={handleAddNode}
                className={styles["save-btn"]}
              >
                ì €ì¥
              </button>
            </div>
          </div>
        </div>
      )}

      {/* ì¹´í…Œê³ ë¦¬ ì¶”ê°€ ëª¨ë‹¬ */}
      {showCategoryModal && (
        <div className={styles["modal-overlay"]} onClick={() => setShowCategoryModal(false)}>
          <div className={styles["node-modal-content"]} onClick={(e) => e.stopPropagation()}>
            {/* ì œëª© */}
            <div className={styles["node-modal-title"]}>
              <h3>ì¹´í…Œê³ ë¦¬ ì¶”ê°€</h3>
              <div className={styles["title-underline"]}></div>
            </div>

            {/* ì¹´í…Œê³ ë¦¬ ì„ íƒ */}
            <div className={styles["input-fields"]}>
              <select
                value={selectedCategory}
                onChange={(e) => setSelectedCategory(e.target.value)}
                className={styles["category-select"]}
              >
                <option value="">ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>
                {categoryOptions.map((category) => (
                  <option key={category} value={category}>
                    {category}
                  </option>
                ))}
              </select>
            </div>

            {/* ì•¡ì…˜ ë²„íŠ¼ë“¤ */}
            <div className={styles["modal-actions"]}>
              <button
                onClick={() => setShowCategoryModal(false)}
                className={styles["cancel-btn"]}
              >
                ì·¨ì†Œ
              </button>
              <button
                onClick={handleAddCategory}
                className={styles["save-btn"]}
              >
                ì €ì¥
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
