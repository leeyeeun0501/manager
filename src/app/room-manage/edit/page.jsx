// room-manage/edit
"use client"
import React, { useEffect, useRef, useState } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import styles from "../room-manage.module.css"

export default function RoomManageEditPage() {
  const router = useRouter()
  const searchParams = useSearchParams()
  const building = searchParams.get("building") || ""
  const floor = searchParams.get("floor") || ""

  const [svgRaw, setSvgRaw] = useState("")
  const [svgViewBox, setSvgViewBox] = useState({ x: 0, y: 0, width: 400, height: 400 })
  const [edges, setEdges] = useState([])
  const [svgNodes, setSvgNodes] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState("")
  const [showNodeModal, setShowNodeModal] = useState(false)
  const [showCategoryModal, setShowCategoryModal] = useState(false)
  const [newNodeName, setNewNodeName] = useState("")
  const [newCategoryName, setNewCategoryName] = useState("")
  const [nodeType, setNodeType] = useState("stairs") // "stairs" or "normal"
  const [autoGeneratedName, setAutoGeneratedName] = useState("")
  const [nodeCounter, setNodeCounter] = useState(1)
  const [pendingNodes, setPendingNodes] = useState([]) // 임시로 추가된 노드들
  const [isAddingMode, setIsAddingMode] = useState(false) // 노드 추가 모드

  const CANVAS_WIDTH = 1000
  const CANVAS_HEIGHT = 700
  const mapContainerRef = useRef(null)

  // 자동 생성 노드명 업데이트
  useEffect(() => {
    if (nodeType === "normal") {
      setAutoGeneratedName(`b${nodeCounter}`)
    }
  }, [nodeType, nodeCounter])

  // 도면 클릭 핸들러
  const handleMapClick = (event) => {
    if (!isAddingMode) return

    // SVG 컨테이너의 실제 크기와 위치 가져오기
    const containerRect = mapContainerRef.current.getBoundingClientRect()
    const scale = Math.min(CANVAS_WIDTH / svgViewBox.width, CANVAS_HEIGHT / svgViewBox.height)
    const offsetX = (CANVAS_WIDTH - svgViewBox.width * scale) / 2
    const offsetY = (CANVAS_HEIGHT - svgViewBox.height * scale) / 2

    // 클릭한 위치를 SVG 좌표계로 변환 (더 간단한 방법)
    const relativeX = event.clientX - containerRect.left
    const relativeY = event.clientY - containerRect.top
    
    // SVG 컨테이너 내에서의 비율 계산
    const clickX = (relativeX / containerRect.width) * svgViewBox.width
    const clickY = (relativeY / containerRect.height) * svgViewBox.height

    // 디버깅을 위한 로그
    console.log("클릭 좌표 변환:", {
      clientX: event.clientX,
      clientY: event.clientY,
      containerRect: {
        left: containerRect.left,
        top: containerRect.top,
        width: containerRect.width,
        height: containerRect.height
      },
      offsetX,
      offsetY,
      scale,
      clickX,
      clickY,
      svgViewBox
    })

    // 새로운 노드 생성
    const newNodeId = nodeType === "stairs" ? newNodeName.trim() : `b${nodeCounter}`
    const newNode = {
      id: `${building}@${floor}@${newNodeId}`,
      x: clickX,
      y: clickY,
      width: 20,
      height: 20,
      element: "circle",
      layer: "Navigation_Nodes",
      nodeType: nodeType,
      isPending: true
    }

    setPendingNodes(prev => [...prev, newNode])
    
    // 일반 노드인 경우 카운터 증가
    if (nodeType === "normal") {
      setNodeCounter(prev => prev + 1)
    }

    // 모달 닫기
    setShowNodeModal(false)
    setIsAddingMode(false)
  }

  function parseNodeInfo(fullId) {
    const parts = (fullId || "").split("@")
    if (parts.length < 3) return { building: "", floor: "", node: "" }
    return { building: parts[0], floor: parts[1], node: parts[2] }
  }

  const handleAddNode = () => {
    // 계단인 경우 노드 이름이 필요
    if (nodeType === "stairs" && !newNodeName.trim()) {
      alert("노드명을 입력해주세요.")
      return
    }
    
    // 노드 추가 모드로 전환
    setIsAddingMode(true)
    setShowNodeModal(false)
    alert("도면에서 노드를 추가할 위치를 클릭해주세요.")
  }

  // 수정 완료 함수
  const handleSaveChanges = async () => {
    if (pendingNodes.length === 0) {
      alert("추가된 노드가 없습니다.")
      return
    }

    try {
      // SVG 파일에 노드 추가
      const modifiedSvg = addNodesToSvg(svgRaw, pendingNodes)
      
      // 서버에 수정된 SVG와 노드 정보 전송
      const response = await fetch("/api/map-route", {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          building,
          floor,
          svgContent: modifiedSvg,
          newNodes: pendingNodes
        }),
      })

      if (response.ok) {
        alert("노드가 성공적으로 추가되었습니다.")
        setPendingNodes([])
        setNewNodeName("")
        setNodeType("stairs")
        setAutoGeneratedName("")
        // 페이지 새로고침으로 업데이트된 노드 목록 가져오기
        window.location.reload()
      } else {
        const errorData = await response.json()
        alert(`노드 추가 실패: ${errorData.message || "알 수 없는 오류"}`)
      }
    } catch (error) {
      console.error("노드 추가 오류:", error)
      alert("노드 추가 중 오류가 발생했습니다.")
    }
  }

  // SVG에 노드 추가하는 함수
  const addNodesToSvg = (svgXml, nodes) => {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    
    let navigationLayer = doc.querySelector('g[id="Navigation_Nodes"]') ||
                         doc.querySelector('g[id="navigation_nodes"]') ||
                         doc.querySelector('g[id="Navigation_nodes"]') ||
                         doc.querySelector('g[id="navigation-nodes"]')

    // Navigation_Nodes 레이어가 없으면 생성
    if (!navigationLayer) {
      navigationLayer = doc.createElementNS("http://www.w3.org/2000/svg", "g")
      navigationLayer.setAttribute("id", "Navigation_Nodes")
      doc.querySelector("svg").appendChild(navigationLayer)
    }

    // 각 노드를 SVG 요소로 추가
    nodes.forEach(node => {
      const nodeId = node.id.split("@")[2] // building@floor@nodeId에서 nodeId만 추출
      
      const circle = doc.createElementNS("http://www.w3.org/2000/svg", "circle")
      circle.setAttribute("id", nodeId)
      circle.setAttribute("cx", node.x)
      circle.setAttribute("cy", node.y)
      circle.setAttribute("r", "10")
      circle.setAttribute("fill", node.nodeType === "stairs" ? "#ff6b6b" : "#4ecdc4")
      circle.setAttribute("stroke", "#333")
      circle.setAttribute("stroke-width", "1")
      
      navigationLayer.appendChild(circle)
    })

    return doc.documentElement.outerHTML
  }

  const handleAddCategory = async () => {
    if (!newCategoryName.trim()) {
      alert("카테고리 이름을 입력해주세요.")
      return
    }

    try {
      const response = await fetch("/api/category-route", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          categoryName: newCategoryName.trim(),
        }),
      })

      if (response.ok) {
        alert("카테고리가 성공적으로 추가되었습니다.")
        setNewCategoryName("")
        setShowCategoryModal(false)
      } else {
        const errorData = await response.json()
        alert(`카테고리 추가 실패: ${errorData.message || "알 수 없는 오류"}`)
      }
    } catch (error) {
      console.error("카테고리 추가 오류:", error)
      alert("카테고리 추가 중 오류가 발생했습니다.")
    }
  }

  function processSvg(svgXml) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    const svgEl = doc.querySelector("svg")
    if (!svgEl) return svgXml

    const existingViewBox = svgEl.getAttribute("viewBox")
    if (existingViewBox) {
      const parts = existingViewBox.split(/[\s,]+/).map(Number)
      if (parts.length === 4) {
        setSvgViewBox({ x: parts[0], y: parts[1], width: parts[2], height: parts[3] })
        return svgXml
      }
    }

    const width = parseFloat(svgEl.getAttribute("width")) || 400
    const height = parseFloat(svgEl.getAttribute("height")) || 400
    const viewBoxStr = `0 0 ${width} ${height}`
    svgEl.setAttribute("viewBox", viewBoxStr)
    setSvgViewBox({ x: 0, y: 0, width, height })
    svgEl.removeAttribute("width")
    svgEl.removeAttribute("height")

    return doc.documentElement.outerHTML
  }

  function parseSvgNodes(svgXml, buildingName, floorName) {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    const nodes = []

    const navigationLayer =
      doc.querySelector('g[id="Navigation_Nodes"]') ||
      doc.querySelector('g[id="navigation_nodes"]') ||
      doc.querySelector('g[id="Navigation_nodes"]') ||
      doc.querySelector('g[id="navigation-nodes"]')

    if (!navigationLayer) {
      return []
    }

    const allElements = navigationLayer.querySelectorAll("*[id]")
    allElements.forEach((element) => {
      const nodeSuffix = element.getAttribute("id")
      if (!nodeSuffix) return
      const fullNodeId = `${buildingName}@${floorName}@${nodeSuffix}`

      let x = 0, y = 0, width = 0, height = 0
      switch (element.tagName.toLowerCase()) {
        case "rect":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 0)
          height = parseFloat(element.getAttribute("height") || 0)
          break
        case "circle":
          x = parseFloat(element.getAttribute("cx") || 0)
          y = parseFloat(element.getAttribute("cy") || 0)
          width = height = parseFloat(element.getAttribute("r") || 0) * 2
          break
        case "ellipse":
          x = parseFloat(element.getAttribute("cx") || 0)
          y = parseFloat(element.getAttribute("cy") || 0)
          width = parseFloat(element.getAttribute("rx") || 0) * 2
          height = parseFloat(element.getAttribute("ry") || 0) * 2
          break
        case "line":
          x = parseFloat(element.getAttribute("x1") || 0)
          y = parseFloat(element.getAttribute("y1") || 0)
          const x2 = parseFloat(element.getAttribute("x2") || 0)
          const y2 = parseFloat(element.getAttribute("y2") || 0)
          width = Math.abs(x2 - x)
          height = Math.abs(y2 - y)
          break
        case "polygon":
        case "polyline":
          const points = element.getAttribute("points") || ""
          const pointsArray = points.split(/[\s,]+/).filter((p) => p).map(Number)
          if (pointsArray.length >= 2) {
            const xCoords = pointsArray.filter((_, i) => i % 2 === 0)
            const yCoords = pointsArray.filter((_, i) => i % 2 === 1)
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "path":
          const d = element.getAttribute("d") || ""
          const matches = d.match(/[ML]\s*([0-9.-]+)\s*,?\s*([0-9.-]+)/g)
          if (matches && matches.length > 0) {
            const coords = matches.map((m) => {
              const nums = m.replace(/[ML]\s*/, "").split(/[\s,]+/).map(Number)
              return { x: nums[0] || 0, y: nums[1] || 0 }
            })
            const xCoords = coords.map((c) => c.x)
            const yCoords = coords.map((c) => c.y)
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "text":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = element.textContent ? element.textContent.length * 8 : 50
          height = 20
          break
        case "g":
          const transform = element.getAttribute("transform") || ""
          const translateMatch = transform.match(/translate\(([^)]+)\)/)
          if (translateMatch) {
            const translateValues = translateMatch[1].split(/[\s,]+/).map(Number)
            x = translateValues[0] || 0
            y = translateValues[1] || 0
          }
          width = height = 20
          break
        default:
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 20)
          height = parseFloat(element.getAttribute("height") || 20)
      }

      nodes.push({ id: fullNodeId, x, y, width, height, element: element.tagName.toLowerCase(), layer: "Navigation_Nodes" })
    })

    return nodes
  }

  useEffect(() => {
    if (!building || !floor) return

    setLoading(true)
    setError("")

    fetch(`/api/map-route?building=${encodeURIComponent(building)}&floor=${encodeURIComponent(floor)}`)
      .then((res) => res.json())
      .then((data) => {
        const fileList = Array.isArray(data) ? data : [data]
        const rawSvgUrl = fileList[0]?.File
        const nodesInfo = fileList[0]?.nodes || {}
        let edgesInfo = fileList[0]?.edges

        if (!edgesInfo) {
          edgesInfo = []
          Object.entries(nodesInfo).forEach(([from, arr]) => {
            arr.forEach((edgeObj) => {
              const to = typeof edgeObj === "string" ? edgeObj : (edgeObj.node || edgeObj.to)
              if (to) edgesInfo.push({ from, to })
            })
          })
        }

        if (rawSvgUrl) {
          const svgUrl = rawSvgUrl + (rawSvgUrl.includes("?") ? "&" : "?") + "ts=" + Date.now()
          setSvgRaw("")
          setSvgNodes([])
          setEdges([])

          fetch(svgUrl)
            .then((res) => res.text())
            .then((svgXml) => {
              const processedSvg = processSvg(svgXml)
              setSvgRaw(processedSvg)
              setEdges(edgesInfo)
              const parsedNodes = parseSvgNodes(svgXml, building, floor)
              setSvgNodes(parsedNodes)
            })
            .catch(() => {
              setSvgRaw("")
              setSvgNodes([])
              setEdges([])
              setError("도면을 불러오지 못했습니다.")
            })
        } else {
          setSvgRaw("")
          setSvgNodes([])
          setEdges([])
          setError("해당 건물/층의 맵 파일을 찾을 수 없습니다.")
        }
      })
      .catch(() => {
        setSvgRaw("")
        setSvgNodes([])
        setEdges([])
        setError("맵 데이터를 불러오지 못했습니다.")
      })
      .finally(() => setLoading(false))
  }, [building, floor])

  return (
    <div 
      className={`${styles["room-root"]} ${styles["edit-page-root"]}`}
      style={{
        margin: 0,
        padding: 0,
        width: '100vw',
        height: '100vh',
        background: '#f4f7fc',
        overflow: 'hidden',
        position: 'fixed',
        top: 0,
        left: 0
      }}
    >
      <span className={styles["room-header"]}>도면 편집 페이지</span>
      {building && floor && (
        <div
          style={{
            width: "100%",
            fontSize: 16,
            color: "#2574f5",
            fontWeight: 600,
            marginBottom: 12,
            textAlign: "center",
            whiteSpace: "nowrap",
            overflow: "hidden",
          }}
        >
          건물명: {building} / 층수: {floor}
        </div>
      )}
      <div className={styles["room-content"]}>
        <div className={styles["room-manage-map-wrap"]} style={{ position: "relative" }}>
          {/* 툴바 */}
          <div className={styles["edit-toolbar"]}>
            <button
              onClick={() => setShowNodeModal(true)}
              className={`${styles["toolbar-btn"]} ${styles["node-btn"]}`}
              title="노드 추가"
            >
              <div className={styles["toolbar-circle"]}></div>
            </button>
            <button
              onClick={() => setShowCategoryModal(true)}
              className={`${styles["toolbar-btn"]} ${styles["category-btn"]}`}
              title="카테고리 추가"
            >
              <div className={styles["toolbar-circle"]}></div>
            </button>
          </div>
          
          <div style={{ textAlign: "right", marginBottom: "8px" }}>
            {pendingNodes.length > 0 && (
              <button
                onClick={handleSaveChanges}
                style={{
                  padding: "6px 14px",
                  fontSize: "14px",
                  fontWeight: "bold",
                  color: "#fff",
                  backgroundColor: "#28a745",
                  border: "none",
                  borderRadius: "6px",
                  cursor: "pointer",
                  marginRight: "8px"
                }}
              >
                수정 완료 ({pendingNodes.length}개 노드)
              </button>
            )}
            <button
              onClick={() => router.back()}
              style={{
                padding: "6px 14px",
                fontSize: "14px",
                fontWeight: "bold",
                color: "#fff",
                backgroundColor: "#2574f5",
                border: "none",
                borderRadius: "6px",
                cursor: "pointer",
                marginRight: "8px"
              }}
            >
              뒤로가기
            </button>
          </div>
          <div
            style={{ position: "relative", width: CANVAS_WIDTH, height: CANVAS_HEIGHT, border: "1px solid #ddd", backgroundColor: "#f8f9fa", overflow: "hidden" }}
          >
            {loading && (
              <div className={styles["room-manage-canvas-placeholder"]}>맵 로딩 중...</div>
            )}
            {!loading && (!building || !floor) && (
              <div className={styles["room-manage-canvas-placeholder"]}>URL의 building/floor 파라미터가 필요합니다.</div>
            )}
            {!loading && building && floor && !svgRaw && (
              <div className={styles["room-manage-canvas-placeholder"]}>{error || "해당 건물/층의 맵 파일을 찾을 수 없습니다."}</div>
            )}

            {!loading && building && floor && svgRaw && (() => {
              const scale = Math.min(CANVAS_WIDTH / svgViewBox.width, CANVAS_HEIGHT / svgViewBox.height)
              const offsetX = (CANVAS_WIDTH - svgViewBox.width * scale) / 2
              const offsetY = (CANVAS_HEIGHT - svgViewBox.height * scale) / 2

              return (
                <div
                  ref={mapContainerRef}
                  onClick={handleMapClick}
                  style={{
                    width: svgViewBox.width,
                    height: svgViewBox.height,
                    transform: `translate(${offsetX}px, ${offsetY}px) scale(${scale})`,
                    transformOrigin: "top left",
                    position: "relative",
                    cursor: isAddingMode ? "crosshair" : "default",
                  }}
                >
                  <div
                    style={{ position: "absolute", top: 0, left: 0, width: "100%", height: "100%" }}
                    dangerouslySetInnerHTML={{ __html: svgRaw }}
                  />


                  {/* 기존 노드들 */}
                  {svgNodes.map((node, index) => (
                    <div
                      key={`node-overlay-${node.id}-${index}`}
                      style={{
                        position: "absolute",
                        left: `${node.x - node.width / 2}px`,
                        top: `${node.y - node.height / 2}px`,
                        width: `${node.width}px`,
                        height: `${node.height}px`,
                        border: "1px solid #007bff",
                        backgroundColor: "rgba(0, 123, 255, 0.08)",
                        borderRadius: 4,
                      }}
                      title={`ID: ${node.id}`}
                    />
                  ))}
                  
                  {/* 임시로 추가된 노드들 */}
                  {pendingNodes.map((node, index) => (
                    <div
                      key={`pending-node-${node.id}-${index}`}
                      style={{
                        position: "absolute",
                        left: `${node.x - node.width / 2}px`,
                        top: `${node.y - node.height / 2}px`,
                        width: `${node.width}px`,
                        height: `${node.height}px`,
                        border: "2px solid #ff6b6b",
                        backgroundColor: "rgba(255, 107, 107, 0.2)",
                        borderRadius: "50%",
                        animation: "pulse 1.5s infinite",
                      }}
                      title={`새 노드: ${node.id}`}
                    />
                  ))}
                </div>
              )
            })()}
          </div>
        </div>
      </div>

      {/* 노드 추가 모달 */}
      {showNodeModal && (
        <div className={styles["modal-overlay"]} onClick={() => setShowNodeModal(false)}>
          <div className={styles["node-modal-content"]} onClick={(e) => e.stopPropagation()}>
            {/* 제목 */}
            <div className={styles["node-modal-title"]}>
              <h3>노드 추가</h3>
              <div className={styles["title-underline"]}></div>
            </div>

            {/* 라디오 버튼 선택 */}
            <div className={styles["node-type-selection"]}>
              <label className={styles["radio-option"]}>
                <input
                  type="radio"
                  name="nodeType"
                  value="stairs"
                  checked={nodeType === "stairs"}
                  onChange={(e) => setNodeType(e.target.value)}
                />
                <span className={styles["radio-custom"]}></span>
                계단
              </label>
              <label className={styles["radio-option"]}>
                <input
                  type="radio"
                  name="nodeType"
                  value="normal"
                  checked={nodeType === "normal"}
                  onChange={(e) => setNodeType(e.target.value)}
                />
                <span className={styles["radio-custom"]}></span>
                노드
              </label>
            </div>

            {/* 자동 생성 노드명 표시 */}
            {nodeType === "normal" && (
              <div className={styles["auto-generated-name"]}>
                자동 생성 노드명: {autoGeneratedName}
              </div>
            )}

            {/* 입력 필드 */}
            {nodeType === "stairs" && (
              <div className={styles["input-fields"]}>
                <input
                  type="text"
                  value={newNodeName}
                  onChange={(e) => setNewNodeName(e.target.value)}
                  placeholder="노드명"
                  className={styles["name-input"]}
                />
              </div>
            )}

            {/* 액션 버튼들 */}
            <div className={styles["modal-actions"]}>
              <button
                onClick={() => setShowNodeModal(false)}
                className={styles["cancel-btn"]}
              >
                취소
              </button>
              <button
                onClick={handleAddNode}
                className={styles["save-btn"]}
              >
                저장
              </button>
            </div>
          </div>
        </div>
      )}

      {/* 카테고리 추가 모달 */}
      {showCategoryModal && (
        <div className={styles["modal-overlay"]} onClick={() => setShowCategoryModal(false)}>
          <div className={styles["modal-content"]} onClick={(e) => e.stopPropagation()}>
            <h3 style={{ marginBottom: "20px", color: "#2574f5" }}>카테고리 추가</h3>
            <div style={{ marginBottom: "20px" }}>
              <label style={{ display: "block", marginBottom: "8px", fontWeight: "600" }}>
                카테고리 이름:
              </label>
              <input
                type="text"
                value={newCategoryName}
                onChange={(e) => setNewCategoryName(e.target.value)}
                placeholder="카테고리 이름을 입력하세요"
                style={{
                  width: "100%",
                  padding: "10px",
                  border: "1px solid #ddd",
                  borderRadius: "6px",
                  fontSize: "14px",
                  outline: "none",
                  boxSizing: "border-box"
                }}
                onKeyPress={(e) => e.key === "Enter" && handleAddCategory()}
              />
            </div>
            <div style={{ display: "flex", gap: "10px", justifyContent: "flex-end" }}>
              <button
                onClick={() => setShowCategoryModal(false)}
                style={{
                  padding: "8px 16px",
                  border: "1px solid #ddd",
                  borderRadius: "6px",
                  backgroundColor: "#fff",
                  cursor: "pointer"
                }}
              >
                취소
              </button>
              <button
                onClick={handleAddCategory}
                style={{
                  padding: "8px 16px",
                  border: "none",
                  borderRadius: "6px",
                  backgroundColor: "#2574f5",
                  color: "#fff",
                  cursor: "pointer"
                }}
              >
                추가
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  )
}
