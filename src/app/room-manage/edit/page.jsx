// 도면 편집
"use client"
import React, { useEffect, useRef, useState, useCallback, useMemo } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import styles from "../room-manage.module.css"
import { apiGet, parseJsonResponse } from "../../utils/apiHelper"
import { useSessionCheck } from "../../utils/useSessionCheck"
import { useToast } from "../../utils/useToast"
import Menu from "../../components/menu"
import NodeModal from "./NodeModal"
import CategoryModal from "./CategoryModal"
import InfoModal from "./InfoModal"
import EditToolbar from "./EditToolbar"
import MapCanvas from "./MapCanvas"

export default function RoomManageEditPage() {
  // 세션 체크 활성화
  useSessionCheck()
  
  const router = useRouter()
  const searchParams = useSearchParams()
  const building = searchParams.get("building") || ""
  const floor = searchParams.get("floor") || ""
  const [menuOpen, setMenuOpen] = useState(false)

  const [svgRaw, setSvgRaw] = useState("")
  const [svgViewBox, setSvgViewBox] = useState({ x: 0, y: 0, width: 400, height: 400 })
  const [edges, setEdges] = useState([])
  const [svgNodes, setSvgNodes] = useState([])
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState("")
  const [showNodeModal, setShowNodeModal] = useState(false)
  const [showCategoryModal, setShowCategoryModal] = useState(false)
  const [newNodeName, setNewNodeName] = useState("")
  const [selectedCategory, setSelectedCategory] = useState("")
  const [nodeType, setNodeType] = useState("stairs") // "stairs" or "normal"
  const [autoGeneratedName, setAutoGeneratedName] = useState("")
  const [nodeCounter, setNodeCounter] = useState(1)
  const [pendingNodes, setPendingNodes] = useState([]) // 임시로 추가된 노드들
  const [isAddingMode, setIsAddingMode] = useState(false) // 노드 추가 모드
  const [pendingCategories, setPendingCategories] = useState([]) // 임시로 추가된 카테고리들
  const [isAddingCategoryMode, setIsAddingCategoryMode] = useState(false) // 카테고리 추가 모드
  const [svgCategories, setSvgCategories] = useState([]) // SVG에서 파싱된 카테고리들
  const [selectedInfo, setSelectedInfo] = useState(null) // 선택된 노드/카테고리 정보
  const [showInfoModal, setShowInfoModal] = useState(false) // 정보 모달 표시
  const [deletedNodes, setDeletedNodes] = useState([]) // 삭제된 노드들
  const [deletedCategories, setDeletedCategories] = useState([]) // 삭제된 카테고리들
  
  // 토스트 메시지 훅
  const { toastMessage, toastVisible, showToast } = useToast()

  // 반응형 캔버스 크기 설정
  const [canvasSize, setCanvasSize] = useState({ width: 1000, height: 700 })
  const mapContainerRef = useRef(null)
  
  const handleResize = useCallback(() => {
    // 최대 크기는 1000x700, 그 이하에서는 화면 비율에 맞춰 자동 축소
    const baseWidth = 1000
    const baseHeight = 700
    const width = Math.min(baseWidth, window.innerWidth * 0.8)
    const height = Math.min(baseHeight, window.innerHeight * 0.7)
    setCanvasSize({ width, height })
  }, [])

  useEffect(() => {
    handleResize()
    window.addEventListener("resize", handleResize)
    return () => window.removeEventListener("resize", handleResize)
  }, [handleResize])

  // 카테고리 한글-영어 매핑
  const categoryNameMap = useMemo(() => ({
    cafe: "카페",
    restaurant: "식당",
    convenience: "편의점",
    vending: "자판기",
    water_purifier: "정수기",
    printer: "프린터",
    lounge: "라운지",
    bank: "은행(atm)",
    fire_extinguisher: "소화기",
    gym: "헬스장",
    bookstore: "서점",
    post: "우체국",
  }), [])

  // 미리 정의된 카테고리 목록 (한글 표시용)
  const categoryOptions = useMemo(() => Object.values(categoryNameMap), [categoryNameMap])

  // 기존 노드명과 중복되지 않는 다음 번호 찾기
  const findNextAvailableNodeNumber = useCallback(() => {
    const existingNodeIds = svgNodes.map(node => node.id.split("@")[2]) // building@floor@nodeId에서 nodeId만 추출
    const pendingNodeIds = pendingNodes.map(node => node.id.split("@")[2]) // 임시 노드들의 ID도 확인

    let counter = 1
    while (true) {
      const candidateId = `b${counter}`
      if (!existingNodeIds.includes(candidateId) && !pendingNodeIds.includes(candidateId)) {
        return counter
      }
      counter++
    }
  }, [svgNodes, pendingNodes])

  // 자동 생성 노드명 업데이트
  useEffect(() => {
    if (nodeType === "normal") {
      const nextAvailableNumber = findNextAvailableNodeNumber()
      setNodeCounter(nextAvailableNumber)
      setAutoGeneratedName(`b${nextAvailableNumber}`)
    }
  }, [nodeType, findNextAvailableNodeNumber])

  // 도면 클릭 핸들러
  const handleMapClick = useCallback((event) => {
    if (!isAddingMode && !isAddingCategoryMode) return

    // SVG 컨테이너의 실제 크기와 위치 가져오기
    const containerRect = mapContainerRef.current.getBoundingClientRect()
    const scale = Math.min(canvasSize.width / svgViewBox.width, canvasSize.height / svgViewBox.height)
    const offsetX = (canvasSize.width - svgViewBox.width * scale) / 2
    const offsetY = (canvasSize.height - svgViewBox.height * scale) / 2

    // 클릭한 위치를 SVG 좌표계로 변환 (더 간단한 방법)
    const relativeX = event.clientX - containerRect.left
    const relativeY = event.clientY - containerRect.top

    // SVG 컨테이너 내에서의 비율 계산
    const clickX = (relativeX / containerRect.width) * svgViewBox.width
    const clickY = (relativeY / containerRect.height) * svgViewBox.height


    if (isAddingMode) {
      // 노드 추가 모드
      let newNodeId
      if (nodeType === "stairs") {
        newNodeId = newNodeName.trim()
      } else {
        // 일반 노드인 경우 중복되지 않는 다음 번호 사용
        const nextAvailableNumber = findNextAvailableNodeNumber()
        newNodeId = `b${nextAvailableNumber}`
        setNodeCounter(nextAvailableNumber)
      }
      const newNode = {
        id: `${building}@${floor}@${newNodeId}`,
        x: clickX,
        y: clickY,
        width: 8, // 기존 노드들과 비슷한 크기
        height: 8, // 기존 노드들과 비슷한 크기
        element: "circle",
        layer: "Navigation_Nodes",
        nodeType: nodeType,
        isPending: true
      }

      setPendingNodes(prev => [...prev, newNode])

      // 모달 닫기
      setShowNodeModal(false)
      setIsAddingMode(false)
    } else if (isAddingCategoryMode) {
      // 카테고리 추가 모드
      const englishCategoryName = Object.keys(categoryNameMap).find(
        key => categoryNameMap[key] === selectedCategory
      )

      const newCategory = {
        id: `${building}@${floor}@${englishCategoryName}`,
        x: clickX,
        y: clickY,
        width: 8,
        height: 8,
        element: "rect",
        layer: "Categories",
        categoryType: englishCategoryName,
        isPending: true
      }

      setPendingCategories(prev => [...prev, newCategory])
      setShowCategoryModal(false)
      setIsAddingCategoryMode(false)
    }
  }, [isAddingMode, isAddingCategoryMode, canvasSize, svgViewBox, nodeType, newNodeName, building, floor, findNextAvailableNodeNumber, selectedCategory, categoryNameMap])

  const handleAddNode = useCallback(() => {
    // 계단인 경우 노드 이름이 필요
    if (nodeType === "stairs" && !newNodeName.trim()) {
      showToast("노드명을 입력해주세요.")
      return
    }

    // 노드 추가 모드로 전환
    setIsAddingMode(true)
    setShowNodeModal(false)
    showToast("도면에서 노드를 추가할 위치를 클릭해주세요.")
  }, [nodeType, newNodeName, showToast])

  // SVG에 노드 추가하는 함수 (기존 노드/카테고리 제거 후 새로 추가)
  const addNodesToSvg = useCallback((svgXml, nodes, categories = []) => {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")

    let navigationLayer = doc.querySelector('g[id="Navigation_Nodes"]') ||
                         doc.querySelector('g[id="navigation_nodes"]') ||
                         doc.querySelector('g[id="Navigation_nodes"]') ||
                         doc.querySelector('g[id="navigation-nodes"]')

    // Navigation_Nodes 레이어가 없으면 생성
    if (!navigationLayer) {
      navigationLayer = doc.createElementNS("http://www.w3.org/2000/svg", "g")
      navigationLayer.setAttribute("id", "Navigation_Nodes")
      doc.querySelector("svg").appendChild(navigationLayer)
    } else {
      // 기존 노드들 모두 제거
      while (navigationLayer.firstChild) {
        navigationLayer.removeChild(navigationLayer.firstChild)
      }
    }

    // Categories 레이어 찾기
    let categoriesLayer = doc.querySelector('g[id="Categories"]') ||
                         doc.querySelector('g[id="categories"]') ||
                         doc.querySelector('g[id="Category"]') ||
                         doc.querySelector('g[id="category"]')

    // Categories 레이어가 없으면 생성
    if (!categoriesLayer) {
      categoriesLayer = doc.createElementNS("http://www.w3.org/2000/svg", "g")
      categoriesLayer.setAttribute("id", "Categories")
      doc.querySelector("svg").appendChild(categoriesLayer)
    } else {
      // 기존 카테고리들 모두 제거
      while (categoriesLayer.firstChild) {
        categoriesLayer.removeChild(categoriesLayer.firstChild)
      }
    }

    // 각 노드를 SVG 요소로 추가 (기존 노드와 동일한 스타일)
    nodes.forEach((node) => {
      const nodeId = node.id.split("@")[2] // building@floor@nodeId에서 nodeId만 추출

      const circle = doc.createElementNS("http://www.w3.org/2000/svg", "circle")
      circle.setAttribute("id", nodeId)
      circle.setAttribute("cx", node.x)
      circle.setAttribute("cy", node.y)
      circle.setAttribute("r", "2.1957438") // 기존 노드와 동일한 반지름
      circle.setAttribute("style", "fill:#00ffff;fill-opacity:0;stroke:#ffffff;stroke-width:0") // 기존 노드와 동일한 스타일

      navigationLayer.appendChild(circle)
    })

    // 각 카테고리를 SVG 요소로 추가 (카테고리는 투명하게 설정)
    categories.forEach((category) => {
      const categoryId = category.categoryType // 영어 카테고리명 사용

      const rect = doc.createElementNS("http://www.w3.org/2000/svg", "rect")
      rect.setAttribute("id", categoryId)
      rect.setAttribute("x", category.x - 4.3914876) // rect의 중심이 되도록 x 좌표 조정
      rect.setAttribute("y", category.y - 4.3914876) // rect의 중심이 되도록 y 좌표 조정
      rect.setAttribute("width", "8.7829752") // 기존 노드와 동일한 크기 (반지름 * 2)
      rect.setAttribute("height", "8.7829752") // 기존 노드와 동일한 크기 (반지름 * 2)
      rect.setAttribute("style", "fill:#ff6b6b;fill-opacity:0;stroke:#ff6b6b;stroke-opacity:0;stroke-width:0") // 카테고리는 완전 투명하게 설정

      categoriesLayer.appendChild(rect)
    })

    return doc.documentElement.outerHTML
  }, [])

  const handleAddCategory = useCallback(() => {
    if (!selectedCategory) {
      showToast("카테고리를 선택해주세요.")
      return
    }

    // 카테고리 추가 모드로 전환
    setIsAddingCategoryMode(true)
    setShowCategoryModal(false)
    showToast("도면에서 카테고리를 추가할 위치를 클릭해주세요.")
  }, [selectedCategory, showToast])

  // 노드/카테고리 클릭 핸들러
  const handleNodeClick = useCallback((node) => {
    setSelectedInfo({
      type: 'node',
      id: node.id,
      name: node.id.split('@')[2], // 노드명 추출
      x: node.x,
      y: node.y,
      element: node.element
    })
    setShowInfoModal(true)
  }, [])

  const handleCategoryClick = useCallback((category) => {
    // 카테고리명을 한국어로 변환
    const koreanName = categoryNameMap[category.categoryType] || category.categoryType

    setSelectedInfo({
      type: 'category',
      id: category.id,
      name: koreanName,
      x: category.x,
      y: category.y,
      element: category.element,
      categoryType: category.categoryType // 영어명도 저장
    })
    setShowInfoModal(true)
  }, [categoryNameMap])

  // 노드 삭제 핸들러
  const handleDeleteNode = useCallback((node) => {
    const nodeName = typeof node === 'string' ? node : node.id?.split('@')[2] || node.name
    if (window.confirm(`노드 "${nodeName}"를 삭제하시겠습니까?`)) {
      const nodeToDelete = typeof node === 'string' ? svgNodes.find(n => n.id === node || n.id.split('@')[2] === node) : node
      if (nodeToDelete) {
        setDeletedNodes(prev => [...prev, nodeToDelete])
        setSvgNodes(prev => prev.filter(n => n.id !== nodeToDelete.id))
      }
    }
  }, [svgNodes])

  // 카테고리 삭제 핸들러
  const handleDeleteCategory = useCallback((category) => {
    const categoryToDelete = typeof category === 'string' 
      ? svgCategories.find(c => c.id === category || c.categoryType === category)
      : category
    if (!categoryToDelete) return
    
    const koreanName = categoryNameMap[categoryToDelete.categoryType] || categoryToDelete.categoryType
    if (window.confirm(`카테고리 "${koreanName}"를 삭제하시겠습니까?`)) {
      setDeletedCategories(prev => [...prev, { ...categoryToDelete, isDeleted: true }])
      setSvgCategories(prev => prev.filter(c => c.id !== categoryToDelete.id))
    }
  }, [svgCategories, categoryNameMap])

  // SVG 저장 함수
  const handleSaveSvg = useCallback(async () => {
    if (!building || !floor) {
      showToast("건물과 층 정보가 없습니다.")
      return
    }

    try {
      setLoading(true)

      // 삭제된 요소들을 제외한 노드와 카테고리만 유지
      const remainingNodes = svgNodes.filter(node => !deletedNodes.some(deleted => deleted.id === node.id))
      const remainingCategories = svgCategories.filter(category => !deletedCategories.some(deleted => deleted.categoryType === category.categoryType))

      // 현재 SVG에 남은 노드/카테고리와 새로 추가된 것들을 합쳐서 업데이트
      const allNodes = [...remainingNodes, ...pendingNodes]
      const allCategories = [...remainingCategories, ...pendingCategories]

      const updatedSvg = addNodesToSvg(svgRaw, allNodes, allCategories)

      // SVG를 Blob으로 변환
      const svgBlob = new Blob([updatedSvg], { type: 'image/svg+xml' })

      // FormData 생성
      const formData = new FormData()
      formData.append('file', svgBlob, `${building}_${floor}.svg`)

      // floor-route PUT API 사용
      const token = localStorage.getItem('token')
      const response = await fetch(`/api/floor-route?building=${encodeURIComponent(building)}&floor=${encodeURIComponent(floor)}`, {
        method: 'PUT',
        headers: {
          'Authorization': `Bearer ${token}`
        },
        body: formData
      })

      const data = await response.json()

      if (response.ok) {
        showToast("SVG가 성공적으로 저장되었습니다.")
        // 저장 성공 후, 현재 상태를 새로운 기본 상태로 업데이트합니다.
        // 이렇게 하면 페이지를 새로고침하지 않고도 편집을 계속할 수 있습니다.
        setSvgRaw(updatedSvg)
        setSvgNodes(allNodes)
        setSvgCategories(allCategories)
        // 저장 성공 후 임시 데이터 초기화
        setPendingNodes([])
        setPendingCategories([])
        setDeletedNodes([])
        setDeletedCategories([])
      } else {
        showToast("SVG 저장에 실패했습니다: " + (data.error || "알 수 없는 오류"))
      }
    } catch (error) {
      showToast("SVG 저장 중 오류가 발생했습니다: " + (error.message || "알 수 없는 오류"))
    } finally {
      setLoading(false)
    }
  }, [building, floor, svgRaw, svgNodes, svgCategories, pendingNodes, pendingCategories, deletedNodes, deletedCategories, addNodesToSvg, showToast])

  // SVG 처리 함수들 (fetchMapData보다 먼저 정의)
  const processSvg = useCallback((svgXml) => {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    const svgEl = doc.querySelector("svg")
    if (!svgEl) {
      return { svg: svgXml, viewBox: { x: 0, y: 0, width: 400, height: 400 } }
    }

    const existingViewBox = svgEl.getAttribute("viewBox")
    if (existingViewBox) {
      const parts = existingViewBox.split(/[\s,]+/).map(Number)
      if (parts.length === 4) {
        const viewBox = { x: parts[0], y: parts[1], width: parts[2], height: parts[3] }
        return { svg: svgXml, viewBox }
      }
    }

    const width = parseFloat(svgEl.getAttribute("width")) || 400
    const height = parseFloat(svgEl.getAttribute("height")) || 400
    const viewBoxStr = `0 0 ${width} ${height}`
    svgEl.setAttribute("viewBox", viewBoxStr)
    const viewBox = { x: 0, y: 0, width, height }
    svgEl.removeAttribute("width")
    svgEl.removeAttribute("height")

    return { svg: doc.documentElement.outerHTML, viewBox }
  }, [])

  const parseSvgNodes = useCallback((svgXml, buildingName, floorName) => {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    const nodes = []

    const navigationLayer =
      doc.querySelector('g[id="Navigation_Nodes"]') ||
      doc.querySelector('g[id="navigation_nodes"]') ||
      doc.querySelector('g[id="Navigation_nodes"]') ||
      doc.querySelector('g[id="navigation-nodes"]')

    if (!navigationLayer) {
      return []
    }

    const allElements = navigationLayer.querySelectorAll("*[id]")
    allElements.forEach((element) => {
      const nodeSuffix = element.getAttribute("id")
      if (!nodeSuffix) return
      const fullNodeId = `${buildingName}@${floorName}@${nodeSuffix}`

      let x = 0, y = 0, width = 0, height = 0
      switch (element.tagName.toLowerCase()) {
        case "rect":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 0)
          height = parseFloat(element.getAttribute("height") || 0)
          break
        case "circle":
          x = parseFloat(element.getAttribute("cx") || 0)
          y = parseFloat(element.getAttribute("cy") || 0)
          width = height = parseFloat(element.getAttribute("r") || 0) * 2
          break
        case "ellipse":
          x = parseFloat(element.getAttribute("cx") || 0)
          y = parseFloat(element.getAttribute("cy") || 0)
          width = parseFloat(element.getAttribute("rx") || 0) * 2
          height = parseFloat(element.getAttribute("ry") || 0) * 2
          break
        case "line":
          x = parseFloat(element.getAttribute("x1") || 0)
          y = parseFloat(element.getAttribute("y1") || 0)
          const x2 = parseFloat(element.getAttribute("x2") || 0)
          const y2 = parseFloat(element.getAttribute("y2") || 0)
          width = Math.abs(x2 - x)
          height = Math.abs(y2 - y)
          break
        case "polygon":
        case "polyline":
          const points = element.getAttribute("points") || ""
          const pointsArray = points.split(/[\s,]+/).filter((p) => p).map(Number)
          if (pointsArray.length >= 2) {
            const xCoords = pointsArray.filter((_, i) => i % 2 === 0)
            const yCoords = pointsArray.filter((_, i) => i % 2 === 1)
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "path":
          const d = element.getAttribute("d") || ""
          const matches = d.match(/[ML]\s*([0-9.-]+)\s*,?\s*([0-9.-]+)/g)
          if (matches && matches.length > 0) {
            const coords = matches.map((m) => {
              const nums = m.replace(/[ML]\s*/, "").split(/[\s,]+/).map(Number)
              return { x: nums[0] || 0, y: nums[1] || 0 }
            })
            const xCoords = coords.map((c) => c.x)
            const yCoords = coords.map((c) => c.y)
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "text":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = element.textContent ? element.textContent.length * 8 : 50
          height = 20
          break
        case "g":
          const transform = element.getAttribute("transform") || ""
          const translateMatch = transform.match(/translate\(([^)]+)\)/)
          if (translateMatch) {
            const translateValues = translateMatch[1].split(/[\s,]+/).map(Number)
            x = translateValues[0] || 0
            y = translateValues[1] || 0
          }
          width = height = 20
          break
        default:
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 20)
          height = parseFloat(element.getAttribute("height") || 20)
      }

      nodes.push({ id: fullNodeId, x, y, width, height, element: element.tagName.toLowerCase(), layer: "Navigation_Nodes" })
    })

    return nodes
  }, [])

  // SVG에서 카테고리 파싱하는 함수
  const parseSvgCategories = useCallback((svgXml, buildingName, floorName) => {
    const parser = new DOMParser()
    const doc = parser.parseFromString(svgXml, "image/svg+xml")
    const categories = []

    const categoriesLayer =
      doc.querySelector('g[id="Categories"]') ||
      doc.querySelector('g[id="categories"]') ||
      doc.querySelector('g[id="Category"]') ||
      doc.querySelector('g[id="category"]')

    if (!categoriesLayer) {
      return []
    }

    const allElements = categoriesLayer.querySelectorAll("*[id]")
    allElements.forEach((element) => {
      const categorySuffix = element.getAttribute("id")
      if (!categorySuffix) return
      
      // 숫자 접미사를 포함한 전체 ID를 사용.
      const baseCategoryName = categorySuffix.replace(/-\d+$/, '')
      const fullCategoryId = `${buildingName}@${floorName}@${categorySuffix}`

      let x = 0, y = 0, width = 0, height = 0
      switch (element.tagName.toLowerCase()) {
        case "rect":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 0)
          height = parseFloat(element.getAttribute("height") || 0)
          break
        case "circle":
          const cx = parseFloat(element.getAttribute("cx") || 0)
          const cy = parseFloat(element.getAttribute("cy") || 0)
          width = height = parseFloat(element.getAttribute("r") || 0) * 2
          x = cx - width / 2
          y = cy - height / 2
          break
        case "ellipse":
          x = parseFloat(element.getAttribute("cx") || 0)
          y = parseFloat(element.getAttribute("cy") || 0)
          width = parseFloat(element.getAttribute("rx") || 0) * 2
          height = parseFloat(element.getAttribute("ry") || 0) * 2
          break
        case "line":
          x = parseFloat(element.getAttribute("x1") || 0)
          y = parseFloat(element.getAttribute("y1") || 0)
          const x2 = parseFloat(element.getAttribute("x2") || 0)
          const y2 = parseFloat(element.getAttribute("y2") || 0)
          width = Math.abs(x2 - x)
          height = Math.abs(y2 - y)
          break
        case "polygon":
          const points = element.getAttribute("points") || ""
          const coords = points.split(/[\s,]+/).map(Number)
          const xCoords = coords.filter((_, i) => i % 2 === 0)
          const yCoords = coords.filter((_, i) => i % 2 === 1)
          if (xCoords.length > 0 && yCoords.length > 0) {
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "path":
          const d = element.getAttribute("d") || ""
          const matches = d.match(/[ML]\s*([0-9.-]+)\s*,?\s*([0-9.-]+)/g)
          if (matches && matches.length > 0) {
            const coords = matches.map((m) => {
              const nums = m.replace(/[ML]\s*/, "").split(/[\s,]+/).map(Number)
              return { x: nums[0] || 0, y: nums[1] || 0 }
            })
            const xCoords = coords.map((c) => c.x)
            const yCoords = coords.map((c) => c.y)
            x = Math.min(...xCoords)
            y = Math.min(...yCoords)
            width = Math.max(...xCoords) - x
            height = Math.max(...yCoords) - y
          }
          break
        case "text":
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = element.textContent ? element.textContent.length * 8 : 50
          height = 20
          break
        case "g":
          const transform = element.getAttribute("transform") || ""
          const translateMatch = transform.match(/translate\(([^)]+)\)/)
          if (translateMatch) {
            const translateValues = translateMatch[1].split(/[\s,]+/).map(Number)
            x = translateValues[0] || 0
            y = translateValues[1] || 0
          }
          width = height = 20
          break
        default:
          x = parseFloat(element.getAttribute("x") || 0)
          y = parseFloat(element.getAttribute("y") || 0)
          width = parseFloat(element.getAttribute("width") || 20)
          height = parseFloat(element.getAttribute("height") || 20)
      }

      categories.push({
        id: fullCategoryId,
        x: x + width / 2,
        y: y + height / 2,
        width: width,
        height: height,
        element: element.tagName.toLowerCase(),
        layer: "Categories",
        categoryType: baseCategoryName, // 기본 카테고리명 저장 (영어)
      })
    })

    return categories
  }, [])

  // 도면 데이터 로딩 함수 (processSvg, parseSvgNodes, parseSvgCategories 이후에 정의)
  const fetchMapData = useCallback(() => {
    if (!building || !floor) return

    setLoading(true)
    setError("")

    apiGet(`/api/map-route?building=${encodeURIComponent(building)}&floor=${encodeURIComponent(floor)}`)
      .then(async (res) => parseJsonResponse(res))
      .then((data) => {
        const fileList = Array.isArray(data) ? data : [data]
        const rawSvgUrl = fileList[0]?.File
        const nodesInfo = fileList[0]?.nodes || {}
        let edgesInfo = fileList[0]?.edges

        if (!edgesInfo) {
          edgesInfo = []
          Object.entries(nodesInfo).forEach(([from, arr]) => {
            arr.forEach((edgeObj) => {
              const to = typeof edgeObj === "string" ? edgeObj : (edgeObj.node || edgeObj.to)
              if (to) edgesInfo.push({ from, to })
            })
          })
        }

        if (rawSvgUrl) {
          const svgUrl = rawSvgUrl + (rawSvgUrl.includes("?") ? "&" : "?") + "ts=" + Date.now()
          fetch(svgUrl)
            .then((res) => res.text())
            .then((svgXml) => {
              const { svg: processedSvg, viewBox } = processSvg(svgXml)
              setSvgRaw(processedSvg)
              setSvgViewBox(viewBox)
              setEdges(edgesInfo)
              setSvgNodes(parseSvgNodes(svgXml, building, floor))
              setSvgCategories(parseSvgCategories(svgXml, building, floor))
            })
            .catch(() => setError("SVG 파일을 불러오지 못했습니다."))
        }
      })
      .catch(() => setError("맵 데이터를 불러오지 못했습니다."))
      .finally(() => setLoading(false))
  }, [building, floor, processSvg, parseSvgNodes, parseSvgCategories])

  useEffect(() => {
    fetchMapData()
  }, [fetchMapData])

  // 모달 열기 핸들러
  const handleOpenNodeModal = useCallback(() => {
    setShowNodeModal(true)
  }, [])

  const handleOpenCategoryModal = useCallback(() => {
    setShowCategoryModal(true)
  }, [])

  const handleCloseNodeModal = useCallback(() => {
    setShowNodeModal(false)
  }, [])

  const handleCloseCategoryModal = useCallback(() => {
    setShowCategoryModal(false)
  }, [])

  const handleCloseInfoModal = useCallback(() => {
    setShowInfoModal(false)
  }, [])

  const handleBack = useCallback(() => {
    router.back()
  }, [router])

  const handleInfoDelete = useCallback((info) => {
    if (info.type === 'node') {
      handleDeleteNode(info)
    } else {
      handleDeleteCategory(info)
    }
  }, [handleDeleteNode, handleDeleteCategory])

  // 저장 가능 여부 계산
  const hasChanges = useMemo(() => {
    return (
      pendingNodes.length > 0 ||
      pendingCategories.length > 0 ||
      deletedNodes.length > 0 ||
      deletedCategories.length > 0
    )
  }, [pendingNodes.length, pendingCategories.length, deletedNodes.length, deletedCategories.length])

  return (
    <div 
      className={`${styles["room-root"]} ${styles["edit-page-root"]}`}
    >
      {/* 토스트 메시지 UI */}
      {toastVisible && (
        <div className={styles.editPageToastPopup}>
          {toastMessage}
        </div>
      )}
      <Menu menuOpen={menuOpen} setMenuOpen={setMenuOpen} />
      <span className={styles["room-header"]}>도면 편집 페이지</span>
      {building && floor && (
        <div className={styles.editPageHeaderInfo}>
          건물명: {building} / 층수: {floor}
        </div>
      )}
      <div className={styles["room-content"]}>
        <div className={`${styles["room-manage-map-wrap"]} ${styles["room-manage-map-wrap-center"]}`}>
          <EditToolbar
            onAddNode={handleOpenNodeModal}
            onAddCategory={handleOpenCategoryModal}
          />
          
          <div className={styles.editPageButtonWrap}>
            {hasChanges && (
              <button
                onClick={handleSaveSvg}
                className={styles.editPageSaveButton}
                disabled={loading}
              >
                수정 완료 (추가: {pendingNodes.length}개 노드, {pendingCategories.length}개 카테고리 / 삭제: {deletedNodes.length}개 노드, {deletedCategories.length}개 카테고리)
              </button>
            )}
            <button
              onClick={handleBack}
              className={styles.editPageBackButton}
              disabled={loading}
            >
              뒤로가기
            </button>
          </div>
          <div 
            className={styles.editPageCanvasContainer}
            style={{ width: canvasSize.width, height: canvasSize.height }}
          >
            {loading && (
              <div className={styles["room-manage-canvas-placeholder"]}>맵 로딩 중...</div>
            )}
            {!loading && (!building || !floor) && (
              <div className={styles["room-manage-canvas-placeholder"]}>URL의 building/floor 파라미터가 필요합니다.</div>
            )}
            {!loading && building && floor && !svgRaw && (
              <div className={styles["room-manage-canvas-placeholder"]}>{error || "해당 건물/층의 맵 파일을 찾을 수 없습니다."}</div>
            )}

            {!loading && building && floor && svgRaw && (
              <MapCanvas
                svgRaw={svgRaw}
                canvasSize={canvasSize}
                svgViewBox={svgViewBox}
                mapContainerRef={mapContainerRef}
                onMapClick={handleMapClick}
                svgNodes={svgNodes}
                deletedNodes={deletedNodes}
                pendingNodes={pendingNodes}
                svgCategories={svgCategories}
                deletedCategories={deletedCategories}
                pendingCategories={pendingCategories}
                onNodeClick={handleNodeClick}
                onCategoryClick={handleCategoryClick}
                isAddingMode={isAddingMode}
                isAddingCategoryMode={isAddingCategoryMode}
                categoryNameMap={categoryNameMap}
              />
            )}
          </div>
        </div>
      </div>

      <NodeModal
        show={showNodeModal}
        onClose={handleCloseNodeModal}
        nodeType={nodeType}
        setNodeType={setNodeType}
        newNodeName={newNodeName}
        setNewNodeName={setNewNodeName}
        autoGeneratedName={autoGeneratedName}
        onAdd={handleAddNode}
      />

      <CategoryModal
        show={showCategoryModal}
        onClose={handleCloseCategoryModal}
        selectedCategory={selectedCategory}
        setSelectedCategory={setSelectedCategory}
        categoryOptions={categoryOptions}
        onAdd={handleAddCategory}
      />

      <InfoModal
        show={showInfoModal}
        onClose={handleCloseInfoModal}
        selectedInfo={selectedInfo}
        onDelete={handleInfoDelete}
      />
    </div>
  )
}
